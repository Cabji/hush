class("hush::xdccobject","object")
{
	function updateInfo(updates info for an active transfer)
	{
		# this function will update all relevant info in the object while an xdccobject's transfer is active
		# this function is usually called by a timer (probably hush::doDCCTimer) but can be called anywhere
		
		# in future add any additional xdccobject info updating to this function
		%id = @%info{"sessionID"}
		
		@%info{"averageSpeed"} = $dcc.averageSpeed(%id)
		@%info{"currentSpeed"} = $dcc.currentSpeed(%id)
		@%info{"filesize"} = $file.size($dcc.localFileName(%id))
		@%info{"percentComplete"} = $str.printf("?.2f",$($real(@%info{"filesize"}) / $real(@%info{"fileTotalSize"}) * 100))
		
		@$emit(infoUpdated,@%info{"downloadQNum"},@%info{"searchTerm"},@%info{"dhIDNum"});
	}
	
	function timerUpdateInfo(initializes or kills a timer that will periodically update info in an xdccobject)
	{
		/* this function is used to start or kill a timer that will periodically update the properties of an xdccobject
		it is mainly used while an object is downloading to update the transfer stats and local filesize
		
		$0 - boolean: true will start the timer, false will kill it
		$1 - string: identifier - the searchTerm|||index id of the xdccObject inside the Hush downloadHash
		
		because there can be multiple xdccobjects that need updating at the same time, the timer name needs to use the 
		second parameter to ID which timer we are interacting with.
		*/
		%success = $false
		%start = $0
		%id = $1
		
		if (%id)
		{
			%thisDL = $str.split(|||,%id)
			if (%start)
			{
				if (%thisDL[0] != "" && %thisDL[1] != "")
				{
					# start the timer
					timer (hushXdccObjectUpdateInfo-%id, 1000, %thisDL[0], %thisDL[1])
					{
						%G_hushDownloadHash{$0}[$1]->$updateInfo;
					}	
					if (%G_hush->%debug) {debug -c timer 'hushXdccObjectUpdateInfo-%id' activated to fire on interval of 1 second\nUse: /listtimers to see timer info;}
					%success = $true
				}
				else
				{
					if (%G_hush->%debug) {debug -c could not start xdccObjectUpdateTimer because id values were incorrect.\n thisDL[0]: %thisDL[0]\n thisDL[1]: %thisDL[1]\nCheck data and try again.;}
				}
			}
			else
			{
				# kill the timer
				killtimer -q hushXdccObjectUpdateInfo-%id
				if (%G_hush->%debug) {debug -c timer 'hushXdccObjectUpdateInfo-%id' killed;}
				%success = $true
			}
		}
		else
		{
			if (%G_hush->%debug) {debug -c parameter id was empty, cannot interact with timer without it. check data and try again.;}	
		}
		
		return %success;
	}
	
	function setInfo($0 = info name, $1 = info value)
	{
		%return = $false
		if ($0 == mediaCategory)
		{
			for (%i = 0; %i < @%mCats[]#; %i++)
			{
				if (@%info{"$0"}->$textAt(%i) == $1)
				{
					@%info{"$0"}->$setCurrentItem(%i)
					# check if download queue editor list items exist, update them if they do because some xdccobject info just changed
					if ($isSet(%G_hush->%queueeditor->%lviDownloads) && $typeOf(%G_hush->%queueeditor->%lviDownloads) == array && %G_hush->%queueeditor->%lviDownloads[]# > 0)
					{
						%G_hush->%queueditor->$refreshQueue();
					}
					%return = $true;
				}
			}
			if (%G_hush->%debug) {debug -c couldn't find value: '$1' in xdccObject::@\%info{mediaCategory} combobox. Check value passed to this function is correct.;}
		}
		else
		{
			@%info{"$0"} = $1	
			%return = $true
		}
		
		return %return
	}
	
	function getInfo($0 = info name)
	{
		if ($isSet(@%info{"$0"})) 
		{
			if ($0 == mediaCategory)
			{
				%rv = @%info{"mediaCategory"}->$textAt(@%info{"mediaCategory"}->$currentItem())
			}
			else
			{
				%rv = @%info{"$0"}
			}
			return %rv;
		}
		else 
		{
			#debug -c oops: there's no property named '$0' in the xdcc object; 
			return $false
		}
	}
	
	function debugThis(show something about the xdccbobject for debugging)
	{
		if ($str.match($0,"Properties, Values, Info"))
		{
			foreach (%key, $keys(@%info))
			{
				%s .= "%key = @%info{"%key"}\n"
			}
		}
		
		debug -c %s
	}
	
	function constructor($0 = dcc session id)
	{
		# create a 'xdccobject' object for tracking DCC transfers
		# note: sessionID is the DCC Session ID that is gotten from DCC Events. It is not the IRC context value.
		
		# set all the values from the parameters passed on the object creation
		
		/* constructor parameter order: 
		 0: networkName - this is the string name of the network the pack is on, needs to be converted to irc context number
		 1: channelName
		 2: botName
		 3: packName
		 4: packNum
		 5: packGets
		 6: packSize
		 7: status
		 8: searchTerm
		 9: sendStyle
		10: auto download boolean
		
		%G_hushDownloadHash{%st}[%di] = $new(hush::xdccobject,objectParent,objectName,networkName,channelName,botName,packName,packNum,
		packGets,packSize,status,searchTerm,sendStyle,autoDownload,dhIDNum)
		*/
		
		@%info{"attempts"}			= 0
		@%info{"autoDownload"}		= $10
		@%info{"averageSpeed"}		= 0
		@%info{"botName"}			= $2
		@%info{"channelName"}			= $1
		@%info{"currentSpeed"}		= 0
		@%info{"dhIDNum"}			= $11
		@%info{"downloadQNum"}		= ''
		@%info{"extractFile"}			= ''
		@%info{"extractInner"}		= ''
		@%info{"filesize"}			= 0
		@%info{"fileTotalSize"}		= 0
		@%info{"ircContext"}			= %G_hush->%ircContexts{"$0"}
		@%info{"mediaCategory"}		= $new(combobox, 0)
		@%info{"networkName"}			= $0
		@%info{"packgets"}			= $5
		@%info{"packname"}			= $3
		@%info{"packnum"}			= $4
		@%info{"packsize"}			= $6
		@%info{"percentComplete"}		= 0
		@%info{"searchTerm"}			= $8
		@%info{"sendStyle"}			= $9
		@%info{"sessionID"}			= $null
		@%info{"status"}			= $7
		# widget creations
		
		# category dropdown widget
		@%mCats = $array(eBooks,Movies,Music,Other,Software,TV Shows);
		for (%i = 0; %i < @%mCats[]#; %i++)
		{
			@%info{"mediaCategory"}->$insertItem(@%mCats[%i], %i)
		}
		
		@%transferThreshold = 0.25
		
		# signals
		
		# connect the xdccobject's signal: infoUpdated to the queueeditor's slot function: refreshQueue
		objects.connect $$ infoUpdated %G_hush->%queueeditor refreshItem
		objects.connect $$ infoSet %G_hush->%queueeditor refreshItem
	}
	
	function checkAutoRequest(checks if a search match should be gotten automatically)
	{
		# checks if a found search from events::onChannelMessage::hilights should be automatically requested or not
		
		echo -d this is a test
	}
	
}

class("hush::tvshow","object")
{
	function constructor()
	{
		/* this function is the constructor of the tvshow class 
		
		This object is a theoretical exercise still at the moment and is not employed in code anywhere.
		
		tvshow objects hold info about a single tv show for the hush media library
		the constructor parameters are:
		
		$0 = tv show name (usually found by library::buildTVShows) string
		$1 = existing seasons (the seasons we already have in our collection, partial or complete) csv string 
		$2 = existing episodes (the episodes we already have in our collection) csv string
		$3 = base path (the base path this tv show is stored at) string
		$4 = season paths (the season segment of the tv show's path to the season) csv string
		$5 = episode paths (the episode segment of the tv show's path to the episode) csv string
		
		all parameters are optional
		
		*/
		
		@%name		= $0
		@%seasons		= %G_hush->%common->$fnCSVtoArray($1)
		@%episodes 	= %G_hush->%common->$fnCSVtoArray($2)
		@%basepath	= $3
		@%seasonPaths	= %G_hush->%common->$fnCSVtoArray($4)
		@%episodePaths	= %G_hush->%common->$fnCSVtoArray($5)
	}
	
}

class("hush::searchesimport","widget")
{
	function showHelp(shows help for how to use the searches import function in hush)
	{
		help.open $file.localdir("help/Hush/en/hushSearchesImport.html")
		
		if (@%debug) debug -c info: showing help file via help.open
	}
	
	function fetchResults(fetches the title results from URL)
	{
		/* hush::searchesimport::fetchResults
		
		 this function will fetch a webpage and analyze it depending on the URL page type and hopefully return a list
		 of media titles to add to the passive searches array
		
		 $0 - URL: (string) the url we will retrieve
		 $1 - URL type: (string) the value the user selectes from the dropdown box on the search import widget (tells us which webpage we are getting from)
		
		If arguments are not passed, the function will use values available in the GUI widgets
		
		
		The function will return false if it finds no movie titles, otherwise it will return true
		*/
		if ($typeOf($0) == string) {%url = $0;} else {%url = @%leImportURL->$text();}
		# note: %urlType also has to be set INSIDE the callback code block below. if you alter this value you need to alter the other as well
		if ($typeOf($1) == string) {%urlType = $1;} else {%urlType = @%coboImportURL->$current();}
		
		%incoming = %G_hushOptions{"MediaIncoming"}
		
		if (%url)
		{
			# check if the url passed is a http or https url
			if ($str.match("https{0,1}://.*",%url,r))
			{
		#		debug -c the url matches the regex
				if (%urlType)
				{
					# reset the @%lbResults box entries
					%G_hush->%searchesImport->%lbResults->$clear();
					# fetch the content from the URL
					http.asyncGet --auto-file-name --winctrl=h --existing-file-action=o -i=%urlType --clear (%url, $file.fixpath(%incoming\\hushSearchesImport.html))
					{
						%G_hushSearchesImport = $new(list)
						%callbackSuccess = $false
		#				debug -c \n0: $0\n1: $1\n2: $2\n3: $3\n4: $4
						# dev note: the following values will probably change over time as websites change their source code.
						# if this feature breaks, its most likely these values that need altering
						# the regexps here are used to decide if a line in the file holds a title string or a year string
						# titleGrep is a hash that lets you define what we should grep for to find the title name from a URL type's content
						%titleGrep = $hash("IMDB Lists","^>.*</a>$")
						%titleGrep{"IMDB Calendar"} = "title.*ref_=rlm\">.*</a>"
						# yearMatch is a hash that lets you define what we should grep for to find the release year from a URL type's content
						%yearMatch = $hash("IMDB Lists","<span class=\"lister-item-year text-muted unbold\">.*</span>$")
						%yearMatch{"IMDB Calendar"} = "</a> (.*)$"
						%f = $file.readLines($2)
						if (%f)
						{
							if ($3 != "" && $typeOf($3) == string) {%urlType = $3;}
							else {%urlType = %G_hush->%searchesImport->%coboImportURL->$current();}
		#					debug -c urlType = %urlType
							%title = $false
		#					# dev note: this code probably only works for Movie titles, so far it's untested with TV shows or other video types.
							# code written 20180522
							# loop through file string
							for (%i = 0; %i < %f[]#; %i++)
							{
								# process the data depending on the URL type
								### dev note: this is where you have to add flow for additional external sources
								# each source type will need to process the approved title line and convert it into a title string and year string
								# at this point, we have access to source data in %f%[i] - this is the variable we want to look at
								if (%urlType == "IMDB Lists")
								{
									# get the title if its in this line
									%title = $str.grep(%titleGrep{"IMDB Lists"}, %f[%i], r)
									if (%title) 
									{
										# pull the title from the title line
										%title = $str.rightfromlast($str.chop(%f[%i],4),>)
										# checks if the next line from the possible title contains the title's year (if there is no year line then this probably isnt actually a title we want)
										if ($str.match(%yearMatch{"IMDB Lists"},%f[$(%i + 1)],r))
										{
											# get the year for the title
											%year = $str.rightfromlast($str.chop(%f[$(%i + 1)],8),"(")
											%G_hushSearchesImport->$append(%title %year);
										}
									}
								}
								elseif (%urlType == "IMDB Calendar")
								{
									# get the title if it's in this line
									%title = $str.grep(%titleGrep{"IMDB Calendar"}, %f[%i], r)
									if (%title) 
									{
		#								debug -c this line has a title: %title
										# pull the title from the title line
										%title = $str.rightfromlast($str.chop(%f[%i],11),>)
		#								debug -c we got this title from the line: %title
										if ($str.match(%yearMatch{"IMDB Calendar"},%f[%i],r))
										{
											# get the year for the title
											%year = $str.rightfromlast($str.chop(%f[%i],1),"(")
											%G_hushSearchesImport->$append(%title %year);
										}
									}
								}
		#						### end flow for external source
								else
								{
									if (%G_hush->%debug) {debug -c urlType '%urlType' is not handled :(;}
								}
								%title = $false;
							}
						}
						else
						{
							# outupt debug and probably should add something to notify user
							if (%G_hush->%debug) {debug -c couldn't read lines from file: $2;}
						}
		
		#				debug -c candidates: %G_hushSearchesImport->$count();
						if (%G_hushSearchesImport->$count() == 0) {%zero = "Check/change source URL or Source Type and try again.";}
		#				debug -c take a look at something in G_hushSearchesImport->\$item(int);
						%G_hush->%searchesImport->%lblStatusLeft->$setText("%G_hushSearchesImport->$count titles retrieved.");
						%G_hush->%searchesImport->%lblStatusRight->$setText("Only new, non-existing titles will be added to passive searches.");
						if (%zero) {%G_hush->%searchesImport->%lblStatusRight->$setText(%zero);}
		#				### dev note: this is where we put our found titles into the UI widget
						if (%G_hushSearchesImport->$count() > 0)
						{
		#					debug -c we are adding titles to the lbResults widget;
							%callbackSuccess = %G_hushSearchesImport->$count();
							%G_hushSearchesImport->$sort($true);
							%G_hushSearchesImport->$moveFirst();
							# loop through list of titles found
							do {
								%G_hush->%searchesImport->%lbResults->$insertItem(%G_hushSearchesImport->$current);
							}
							while (%G_hushSearchesImport->$moveNext)
						}
		
						if ((%G_hushOptions{"SearchImportsAutoToggle"} == $true) && (%G_hush->%searchImportsAutoFlag == $true))
						{
							if (%G_hush->%debug) {debug -c Search Import Automated Acquisition is on, and the fetchResults callback run will automatically try to add titles to the Searches list.;}
							if (%G_hush->%debug) {debug -c fetchResults::callback: Number of titles found: %success;}
							# dev-note: the following call must use absolute resolution to the function call because we can be calling this code form a callback scope
							%G_hush->%searchesImport->$addToSearches();
							%G_hush->%searchesImport->%lblStatusLeft->$setText("");
							%G_hush->%searchesImport->%lblStatusRight->$setText("");
							%G_hush->%searchesImport->%lbResults->$clear();
						}
		
						return $true;
		#				### end of UI widget insertion
					} # end of http callback block
					@%lblStatusLeft->$setText("Fetching titles...");
					@%lblStatusRight->$setText("");
				}
				else
				{	
					# didnt get a URL type passed to us, output a dialog telling user
		#			debug -c didn't get a URL type passed to us!
				}
			}
			else
			{
		#		debug -c The URL supplied '%url' does not seem to be a valid URL!
				@%lblStatusLeft->$setText("Supplied URL seems invalid.");
				@%lblStatusRight->$setText("Please check and try again.");
			}
		}
		else
		{
			# didnt get a URL passed to us, output a dialog telling user
		#	debug -c didn't get a URL passed to us!
			@%lblStatusLeft->$setText("No URL supplied.");
		}
		
		return $true
	}
	
	function constructor(runs on object creation)
	{
		# searchesimport class for hush - builds the searches import window
		
		# if this feature breaks, you should probably go look in the fetchResults function, specifically look at the
		# hash variables at hte top called %titleGrep and %yearMatch. If a source website changes their source code 
		# this feature will likely break and give unexpected results or not work at all.
		
		@%l0 = $new(layout, $$)
		
		@$setGeometry(0,0,600,300)
		@$setWindowTitle("Hush::Settings::Searches::Import")
		@$centerToScreen()
		@$setFocus()
		
		@%l0->$setSpacing(3)
		
		### init child widgets for Settings::Searches::Import
		# title label
		@%lblTitle = $new(label, $$)
		@%lblTitle->$setText("<b>Import Searches</b><br/>Import media titles from an external source using this tool. IMDB's Advanced Search and Lists are supported.<br/>")
		@%lblTitle->$setAlignment(Left)
		# button Help
		@%btnHelp = $new(button, $$)
		@%btnHelp->$setText("Click Here for Help")
		
		# label Import URL
		@%lblImportURL = $new(label, $$)
		@%lblImportURL->$setText("URL: ")
		@%lblImportURL->$setAlignment(Center)
		
		# linedit Import URL
		@%leImportURL = $new(lineedit, $$)
		@%leImportURL->$setTooltip("Paste the URL of the page you want to import the new titles from into here.")
		# combobox Import URL type
		@%coboImportURL = $new(combobox, $$)
		@%coboImportURL->$setTooltip("Select where the title names will be pulled from")
		### dev note: the values of items that are inserted here are used as conditionals in searchsimport::fetchResults
		@%coboImportURL->$insertItem("IMDB Lists")
		@%coboImportURL->$insertItem("IMDB Calendar")
		
		# button LAUNCH
		@%btnLAUNCH = $new(button, $$)
		@%btnLAUNCH->$setText(LAUNCH)
		@%btnLAUNCH->$setTooltip("Launches the searches import")
		
		# listbox Results
		@%lbResults = $new(listbox, $$)
		@%lbResults->$setTooltip("Import results are preliminarily shown in here")
		
		# label prepend search string with
		@%lblPrepend = $new(label, $$)
		@%lblPrepend->$setText("Prepend titles with: ")
		@%lblPrepend->$setMinimumWidth(110)
		# lineedit prepend search string with
		@%lePrepend = $new(lineedit, $$)
		@%lePrepend->$setText("*")
		@%lePrepend->$setTooltip("String to prepend the title name in the passive searches list entry.<br/>This string will come before the title name. It will be prepended to all the titles listed above. <br/>Recommended value: *")
		# label append search string with
		@%lblAppend = $new(label, $$)
		@%lblAppend->$setText("Append titles with: ")
		# lineedit append search string with
		@%leAppend = $new(lineedit, $$)
		@%leAppend->$setText("*1080*mkv*")
		@%leAppend->$setTooltip("String to append the title name in the passive searches list entry.<br/>This string will come after the title name.<br/>The append string is ideal for filtering searches to get specific files you want, for example appending: <ul><li><b>*720*bluray*</b> will find any file type that is a 720p bluray release</li><li><b>*1080*</b> will find any release as long as it is 1080p</li><li><b>*1080*bdrip*mkv*</b> will find only MKV files (not tars) that are 1080p and bdrip</li></ul>The value will be appended to all the titles listed above.")
		
		# button Add to Searches
		@%btnAddToSearches = $new(button, $$)
		@%btnAddToSearches->$setText("Add to Passive Searches")
		@%btnAddToSearches->$setTooltip("Once you have retrieved title results, you can review them then click this button to add them to the passive searches list.")
		
		# label status message left side
		@%lblStatusLeft = $new(label, $$)
		@%lblStatusLeft->$setAlignment(Left)
		# label status message right side
		@%lblStatusRight = $new(label, $$)
		@%lblStatusRight->$setAlignment(Right)
		@%lblStatusRight->$setMinimumWidth(400)
		### populate child widgets as needed
		
		### do layout of widgets
		
		#@%l0->$setColumnStretch(0,10)
		#@%l0->$setColumnStretch(3,10)
		@%l0->$addMultiCellWidget(@%lblTitle, 0,0,0,3)
		@%l0->$addMultiCellWidget(@%btnHelp, 1,1,0,3)
		@%l0->$addMultiCellWidget(@%lblImportURL, 2,2,0,0)
		@%l0->$addMultiCellWidget(@%leImportURL, 2,2,1,3)
		@%l0->$addMultiCellWidget(@%coboImportURL, 3,3,0,1)
		@%l0->$addMultiCellWidget(@%btnLAUNCH, 3,3,2,3)
		@%l0->$addMultiCellWidget(@%lbResults, 4,4,0,3)
		@%l0->$addMultiCellWidget(@%lblPrepend, 5,5,0,0)
		@%l0->$addMultiCellWidget(@%lePrepend, 5,5,1,1)
		@%l0->$addMultiCellWidget(@%lblAppend, 5,5,2,2)
		@%l0->$addMultiCellWidget(@%leAppend, 5,5,3,3)
		@%l0->$addMultiCellWidget(@%btnAddToSearches, 6,6,0,3)
		@%l0->$addMultiCellWidget(@%lblStatusLeft, 7,7,0,1)
		@%l0->$addMultiCellWidget(@%lblStatusRight, 7,7,2,3)
		### object connect
		
		objects.connect @%btnHelp clicked $$ showHelp
		objects.connect @%btnLAUNCH clicked $$ fetchResults
		objects.connect @%btnAddToSearches clicked $$ addToSearches
		objects.connect @%coboImportURL activated $$ autoURLValue
	}
	
	function autoURLValue(adds a URL string automatically when the combobox value changes)
	{
		switch (@%coboImportURL->$current())
		{
			case("IMDB Calendar"):
			{
				@%leImportURL->$setText("https://imdb.com/calendar")
				break;
			}
			default:
			{
				@%leImportURL->$setText("")
			}
		}
		
		return $true
	}
	
	function addToSearches(adds a list of titles to the passive search array)
	{
		# this function will return the number of titles added to the Searches list else false or 0
		
		# the warnings array contains words or strings that we should be suspect of in a release title.
		%warnings = $array(untitled)
		
		%specialChars = $array(",", "*", "!", "/", "\\", "?", "$")
		%wildChars = $array(":", "'", ": ", ":.", "*.", ".-.", "&amp;")
		%replaceSpecialWith = ""
		%replaceWildCharsWith = "*"
		
		%counterWarnings = 0
		%counterSearches = 0
		%counterMovies = 0
		%counterPerm = 0
		
		%counterTitlesAdded = 0
		
		%success = $false
		
		if (%G_hush->%debug && %G_hush->%searchImportsAutoFlag) {debug -c This is an automatic movie title acquisition run. \nTo disable this, look at Hush -> Options -> Searching -> Untick \"Automate movie title acquisition\";}
		
		if (%G_hush->%searchesImport->%lbResults->$count > 0)
		{
			# iterate through result list
			for (%i = 0; %i < @%lbResults->$count(); %i++)
			{
				@%lbResults->$setCurrentItem(%i)
				%title = @%lbResults->$currentText
				%keep = $true
				# replace spaces with period
				%title = $str.replace(%title," ",.)
				# remove special characters
				foreach (%v, %specialChars)
				{
					%title = $str.replace(%title,%v,%replaceSpecialWith)
				}
				# replace wildcard characters with asterisk
				foreach (%v, %wildChars)
				{
					%title = $str.replace(%title,%v,%replaceWildCharsWith)
				}
				# lower case the string and put asterisks at start and end, put minQuality after title
				%title = $str.lowcase(%title)
				if (%title)
				{
					# chop the last 5 characters from the title string, as we dont want to compare years just title names
					%temp = $str.chop(%title,5)
					# check if the title has any potentially problematic words in it
					foreach (%v, %warnings)
					{
						if ($str.contains(%title,%v)) 
						{
							if (%G_hush->%debug) {debug -c$k(12) %title$k() contains$k(12) %v$k() - this title won't be added to the passive searches array;}
							%counterWarnings++
							%keep = $false
						}
					}
					# check if the current new title matches any entries in hushSearches array, library array or permanent record array
					if (%keep) {if ($str.grep($str.replace(%temp," ",*),%G_hush->%library->%arr_Movies,w)) {%keep = $false; %counterMovies++;}}
					if (%keep) {if ($str.grep($str.replace(%temp," ",*),%G_hushSearches,w)) {%keep = $false; %counterSearches++;}}
					if (%keep && %G_hushOptions{"SearchImportsObeyPermRecord"}) {if ($str.grep($str.replace(%temp," ",*),%G_hush->%library->%moviesPermRecord,w)) {%keep = $false; %counterPerm++;}}
		
					if (%keep) 
					{
						# advance to next level of flow
						# prepend and append title
						%title = @%lePrepend->$text()%title@%leAppend->$text()
						# add to hush searches array
						%G_hushSearches[%G_hushSearches[]#] = %title
						if (%G_hush->%debug) {debug -c adding $k(8)%title$k() to the Searches list;}
						%counterTitlesAdded++
						%success = %counterTitlesAdded
					}
					else 
					{
		# dev-note: disabled this debug output because we're mostly not interested if we don't insert something we already have in the list.
		#				if (%G_hush->%debug) {debug -c we don't need$k(7) %title$k() it's already in Searches list, Media Library or Permanent Record;}
					}
				}
				else
				{
					if (%G_hush->%debug) {debug -c list item '@%lbResults->$currentItem()' is null;}
				}	
			}
			if ($(@%lbResults->$count() - %counterTitlesAdded) == 1) {%plural = title;} else {%plural = titles;}
			if ($integer(%counterWarnings) == 1) {%pluralWarn = title;} else {%pluralWarn = titles;}
			%csv = ""
			if (%counterTitlesAdded < @%lbResults->$count) {%titlesRemoved = "| $(@%lbResults->$count() - %counterTitlesAdded) %plural excluded: ";}
			if (%counterWarnings > 0) {%titlesRemoved .= "%counterWarnings dodgy %pluralWarn"; %csv = ", ";}
			if (%counterSearches > 0) {%titlesRemoved .= "%csv%counterSearches in Searches"; %csv = ", ";}
			if (%counterMovies > 0) {%titlesRemoved .= "%csv%counterMovies in Media Library"; %csv = ", ";}
			if (%counterPerm > 0) {%titlesRemoved .= "%csv%counterPerm in Permanent Record";}
			@%lblStatusRight->$setText("%counterTitlesAdded passive searches added %titlesRemoved")
			@%lbResults->$setCurrentItem(0)
			# sort hush searches array
			%G_hushSearches = $sort(%G_hushSearches)
		}
		else
		{
			if (%G_hush->%debug) {debug -c No titles found in the import list!;}
		}
		
		if (%G_hush->%debug && %G_hush->%searchImportsAutoFlag) {debug -c End of automatic movie title acquisition;}
		if (%G_hush->%searchImportsAutoFlag == $true) {%G_hush->%searchImportsAutoFlag = $false;}
		
		if (%success) {%G_hush->$configSave(%G_hush->%hushConfig,searches,%G_hushSearches);}
		
		return %success
	}
	
}

class("hush::searches","widget")
{
	function strRegexGrab($0 = string to search; $1 = string to find)
	{
		# this function does the exact opposite to $str.split
		# it allows you to seach a string using a regex, and it will return the portion of the string that
		# matches the regex.
		
		# $0 = string to search
		# $1 = string to look for
		
		%s = $0
		# split full string on regex
		%r = $str.split($1, $0, r)
		
		#if (%G_hush->%debug == $true) echo -d "(@$className)::%fn - r = %r"
		# loop through results from $str.split and wipe them out from original string
		for (%i = 0; %i < %r[]#; %i++)
			%s = $str.replace(%s, %r[%i], "")
		
		#if (%G_hush->%debug == $true) echo -d "(@$className)::%fn - returning value: %s"
		return %s
	}
	
	function setSExceptions(pulls values from search exceptions listbox and puts them into %G_hushSExceptions array)
	{
		# pulls values from listbox lbSExc and puts the values into the %G_hushSExceptions array
		
		if ($isSet(%G_hushSExceptions))
			unset %G_hushSExceptions
		
		for (%i = 0; %i < @%lbSExc->$count(); %i++)
			%G_hushSExceptions[%i] = @%lbSExc->$textAt(%i)
		
		# sort search exceptions array
		%G_hushSExceptions = $sort(%G_hushSExceptions)
		%lblSuffix = " - %G_hushSExceptions[]# entries"
		@%lblSExc->$setText("<b>Search Exceptions</b>"%lblSuffix)
	}
	
	function setSearches(pulls values from the searches list and puts them into %G_hushSearches array)
	{
		# this function pulls the values from the searches list and puts them into the %G_hushSearches array
		
		if ($isSet(%G_hushSearches))
			unset %G_hushSearches
		
		# loop listbox @%lbS entries and put their values into %G_hushSearches[]
		for (%i = 0; %i < @%lbS->$count(); %i++)
			%G_hushSearches[%i] = @%lbS->$textAt(%i)
		
		# sort searches array
		%G_hushSearches = $sort(%G_hushSearches)
		%lblHomeSuffix = " - %G_hushSearches[]# entries"
		@%lblHomeMsg->$setText("<b>Searches</b>"%lblHomeSuffix)
		
		%G_hush->$buildPSQuery()
	}
	
	function rmSearchTerm(removes a search term from the Searches list and the hush searches array)
	{
		# $0: search term to remove
		
		%removeUID = $false
		%searchTerm = $0
		
		# loop through items in Searches listbox
		for (%uid = 0; %uid < @%lbS->$count(); %uid++)
		{
			# check if the text at the listbox entry we've got matches our searchTerm
			if (@%lbS->$textAt(%uid) == %searchTerm)
			{
				# save the uid
				%removeUID = %uid;
				break;
			}
		}
		
		if (%removeUID)
		{
			@%lbS->$removeItem(%removeUID)
			@$setSearches()
			%G_hush->$configSave(%G_hush->%hushConfig, searches, %G_hushSearches)
			return $true;
		}
		
		return $false;
	}
	
	function epUp(this function is used by external fuctions to increment episode values up in a search)
	{
		# this function is used by external functions to increment episode values up in a search.
		# it is most notably used by the auto download functions/aliases
		
		# $0: searchTerm that will be in hush searches array
		# returns a string which is the searchTerm with the incremented value otherwise returns false
		
		if (%G_hushOptions{"TransfersAutoEpUp"} == 1)
		{
			%searchTerm = $0
		
			for (%uid = 0; %uid < @%lbS->$count(); %uid++)
			{
				# check if the text at the listbox entry we've got matches out searchTerm
				if (@%lbS->$textAt(%uid) == %searchTerm)
				{ 
					# alter the episode number up one
					%newSearch = @$epChange(@%lbS->$textAt(%uid), episode, up)
					if (%newSearch != $false)
					{
						if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
						@%lbS->$changeItem(%newSearch, %uid)
						# update the hush searches array
						@$setSearches()
						# save all this jazz to disk
						%G_hush->$closeEvent
						# return the new searchTerm as a true return
						return %newSearch;
					}
					else
					{
						if (%G_hush->%debug) debug -c info: @%lbS->$textAt(%uid) - no episode info found, nothing changes
						return $false;
					}
				}
			}
		}
		
		return $false;
	}
	
	function epChange($0 = hush search string; $1 = change type [s|e|season|episode]; $2 = increment/decrement [inc|dec|increment|decrement|increase|decrease|up|down|reset|one])
	{
		# requires strRegexGrab
		
		# $0 = hush search string
		# $1 = change type [s|e|season|episode]
		# $2 = increment or decrement [inc|dec|increment|decrement|increase|decrease|up|down|reset|one]
		
		# by default, we will increment by episode if $1 is not passed to us or season increment isnt requested
		
		# $2 reset or one will change the season or episode value to 01 (resets it)
		
		if ($str.equal(s, $1) | $str.match(season, $1))
		{
			%type = [sS]
			%bit = s
		}
		else
		{
			%type = [eE]
			%bit = e
		}
		
		# search for season/episode node in the lbS uid
		%seBit = @$strRegexGrab($0, "s[0-9][0-9]e[0-9][0-9]")
		# if we cant find sXXeXX just look for sXX in case this is a full season search
		if (%seBit == "")
		{
			%seBit = @$strRegexGrab($0, "s[0-9][0-9]")
		}
		if (%seBit != "")
		{
			# grab the season or episode token from the season/ep string $0
			# this is finding either "S01" or "E01" for examples
			%token = @$strRegexGrab($0, %type\[0-9][0-9])
		
			# grab the number
			# this is now geting just the number portion from %token and casts it as an integer
			%n = $integer(@$strRegexGrab(%token, [0-9][0-9]))
		
			# increment, decrement or reset the number
			if ($str.match(dec|decrement|decrease|down, $2, r) && %n != 0) { %n--; }
			elseif ($str.match(reset|one, $2, r) && %n != 0) { %n = 1; }
			else { %n++; }
		
			# check if new value is below 10, add leading 0 if it is, else cast it to a string
			if (%n < 10)
				%return = $string(0%n)
			else
				%return = $string(%n)
			# %orig is an array that has two values - the hush search string split at the current season/episode token
			# so %orig[0] holds everything to the left of the token, %orig[1] hold errthing to the right of token
			%orig = $str.split(%type\[0-9][0-9], $0, r)
			%return = %orig[0]%bit%return%orig[1]
		
			# so we are returning the newly changed search string
			return %return
		}
		else
			return $false
	}
	
	function constructor()
	{
		# searches class for hush - builds the Searches settings window
		
		@%import = $new(hush::searchesimport, 0, "Hush Searches Import Widget")
		
		@%layout = $new(layout, $$)
		
		@$setGeometry(0,0,400,250)
		@$setWindowTitle("Hush::Settings::Searches")
		@$centerToScreen()
		@$setFocus()
		
		@%layout->$setSpacing(3)
		
		### init child widgets for Settings::Searches
		
		# Label to get user started
		@%lblHomeMsg = $new(label, $$)
		@%lblHomeMsg->$setText("<b>Searches</b>")
		@%lblHomeMsg->$setTooltip("Hush will watch your channels for the things you add in here. All searches are case insensitive.")
		@%lblHomeMsg->$setAlignment(Left)
		%lblHomeSuffix = " - %G_hushSearches[]# entries"
		@%lblHomeMsg->$setText(@%lblHomeMsg->$text()%lblHomeSuffix)
		# Search query linedit input
		@%leSQ = $new(lineedit, $$)
		@%leSQ->$setText("Enter search to add...")
		@%leSQ->$setTooltip("Search queries can contain wildcard characters: * and ?, but are not required.<br/>Regular expressions are not supported.")
		# Searches add button
		@%btnAdd = $new(button, $$)
		@%btnAdd->$setText("Add")
		@%btnAdd->$setTooltip("Click to add the search to the searches list.")
		# Searches listbox
		@%lbS = $new(listbox, $$)
		@%lbS->$setTooltip("Your current searches.<br/>Channel messages that match these criteria will be considered as a match by Hush.")
		@%lbS->$setSelectionMode(Multi)
		# Searches remove button
		@%btnRm = $new(button, $$)
		@%btnRm->$setText("Remove")
		@%btnRm->$setTooltip("Click to remove selected search(es) from the searches list.")
		
		# Season/Episode Inc/Dec
		@%lblSeasonChange = $new(label, $$)
		@%lblSeasonChange->$setText("Season:")
		@%lblSeasonChange->$setAlignment("Center")
		@%lblSeasonChange->$setTooltip("Hilight a search to alter the season value")
		@%lblEpisodeChange = $new(label, $$)
		@%lblEpisodeChange->$setText("Episode:")
		@%lblEpisodeChange->$setAlignment("Center")
		@%lblEpisodeChange->$setTooltip("Hilight a search to alter the episode value")
		# + and - buttons
		@%btnSUp = $new(button, $$)
		@%btnSUp->$setImage($file.localdir("pics/Hush/up.png"))
		@%btnSUp->$setTooltip("Click to increase the highlighted search's season")
		@%btnSUp->$setMaximumWidth(40)
		@%btnSDown = $new(button, $$)
		@%btnSDown->$setImage($file.localdir("pics/Hush/down.png"))
		@%btnSDown->$setTooltip("Click to decrease the highlighted search's season")
		@%btnSDown->$setMaximumWidth(40)
		@%btnEUp = $new(button, $$)
		@%btnEUp->$setImage($file.localdir("pics/Hush/up.png"))
		@%btnEup->$setTooltip("Click to increase the highlighted search's episode")
		@%btnEUp->$setMaximumWidth(40)
		@%btnEDown = $new(button, $$)
		@%btnEDown->$setImage($file.localdir("pics/Hush/down.png"))
		@%btnEDown->$setTooltip("Click to decrease the highlighted search's episode")
		@%btnEDown->$setMaximumWidth(40)
		@%btnEReset = $new(button, $$)
		@%btnEReset->$setImage($file.localdir("pics/Hush/reset.png"))
		@%btnEReset->$setTooltip("Click to reset the highlighted search's episode back to 01")
		@%btnEReset->$setMaximumWidth(35)
		
		# Label for search exceptions
		@%lblSExc = $new(label, $$)
		@%lblSExc->$setText("<hr/><b>Search Exceptions</b>")
		@%lblSExc->$setTooltip("Search exceptions are used to <u>prevent</u> Hush from matching a search.<br/>Exceptions are useful if the announce channel has messages like<br/>announcements when a pack is first released.<br>You can filter those lines out using exceptions so Hush ignores them.<br/>Examples of search exceptions:<ul><li><b>xxx</b> ignore all pr0n</li><li><b>.cam.</b> ignore all cam releases</li><li><b>hdcam</b> ignore all HD cam releases</li><li><b>korsub</b> ignore all releases with KORSUBs (i <u>hate</u> korsub)</li><li><b>HC</b> ignore all with hard coded subtitles</li></ul>All search exceptions are case insensitive.")
		@%lblSExc->$setAlignment(Left)
		%lblSuffix = " - %G_hushSExceptions[]# entries"
		@%lblSExc->$setText("<b>Search Exceptions</b>"%lblSuffix)
		# Exceptions listbox
		@%lbSExc = $new(listbox, $$)
		@%lbSExc->$setToolTip("Your search exceptions.<br/>Channel messages that match these criteria will not be considered as a match by Hush, even if they match the search criteria above.")
		@%lbSExc->$setSelectionMode(Multi)
		# Exceptions linedit input
		@%leSExc = $new(lineedit, $$)
		@%leSExc->$setText("Enter search exception to add...")
		@%leSExc->$setTooltip("Search exceptions can contain wildcard characters: * and ?, but are not required.<br/>Regular expressions are not supported.")
		# Exceptions add button
		@%btnSExcAdd = $new(button, $$)
		@%btnSExcAdd->$setText("Add")
		@%btnSExcAdd->$setTooltip("Click to add exception to the exceptions list.")
		# Exceptions remove button
		@%btnSExcRm = $new(button, $$)
		@%btnSExcRm->$setText("Remove")
		@%btnSExcRm->$setTooltip("Click to remove selected exception(s) from the list.")
		# Import Searches button
		@%btnImportSearches = $new(button,$$)
		@%btnImportSearches->$setText("Import Searches...")
		@%btnImportSearches->$setTooltip("Click to import a list of titles from an external source")
		
		### Populate child widgets as required
		
		# searches list needs to be populated from %G_hushWatchedChannels to @%lbC listbox
		%G_hushSearches = $sort(%G_hushSearches)
		%G_hushSExceptions = $sort(%G_hushSExceptions)
		for (%i = 0; %i < $length(%G_hushSearches); %i++)
		  @%lbS->$insertItem(%G_hushSearches[%i])
		for (%i = 0; %i < %G_hushSExceptions[]#; %i++)
		  @%lbSExc->$insertItem(%G_hushSExceptions[%i])
		
		### do layout of widgets
		
		@%layout->$setColumnStretch(0,10)
		@%layout->$setColumnStretch(3,10)
		@%layout->$addMultiCellWidget(@%lblHomeMsg, 0,0,0,6)
		@%layout->$addMultiCellWidget(@%leSQ, 1,1,0,5)
		@%layout->$addMultiCellWidget(@%btnAdd, 1,1,6,6)
		@%layout->$addMultiCellWidget(@%lbS, 2,2,0,6)
		@%layout->$addMultiCellWidget(@%btnRm, 3,3,0,6)
		@%layout->$addMultiCellWidget(@%lblSeasonChange, 4,4,0,0)
		@%layout->$addMultiCellWidget(@%btnSUp, 4,4,1,1)
		@%layout->$addMultiCellWidget(@%btnSDown, 4,4,2,2)
		@%layout->$addMultiCellWidget(@%lblEpisodeChange, 4,4,3,3)
		@%layout->$addMultiCellWidget(@%btnEUp, 4,4,4,4)
		@%layout->$addMultiCellWidget(@%btnEDown, 4,4,5,5)
		@%layout->$addMultiCellWidget(@%btnEReset, 4,4,6,6)
		@%layout->$addMultiCellWidget(@%lblSExc, 5,5,0,6)
		@%layout->$addMultiCellWidget(@%leSExc, 6,6,0,5)
		@%layout->$addMultiCellWidget(@%btnSExcAdd, 6,6,6,6)
		@%layout->$addMultiCellWidget(@%lbSExc, 7,7,0,6)
		@%layout->$addMultiCellWidget(@%btnSExcRm, 8,8,0,6)
		@%layout->$addMultiCellWidget(@%btnImportSearches, 9,9,0,6)
		
		@%import = $new(hush::searchesimport, $$)
		@%import->$hide();
		
		objects.connect @%btnImportSearches clicked %G_hush showSearchesImport
		
		### private impls
		
		# search query lineedit input box, change text from default "Enter search query to add..." to "" empty string
		privateimpl(@%leSQ, mousePressEvent)
		{
		  if (@$text() == "Enter search to add..." || @$text() == "")
		    @$setText("")
		}
		
		privateimpl(@%leSQ, keyPressEvent)
		{
		  if ($0 == "Return")
		    @$emit("enterPressed")
		}
		
		# connect %leSQ enterPressed to %btnAdd mousePressEvent
		objects.connect @%leSQ enterPressed @%btnAdd mousePressEvent
		
		# search query add button, add the search in %leSQ lineedit to %lbS listbox
		privateimpl(@%btnAdd, mousePressEvent)
		{
		  # check if text in %leSQ exists, add to %lbS if it does
		  if (@$parent->%leSQ->$text() != "")
		  {
		    # move search query from lineedit to listbox
		    @$parent->%lbS->$insertItem(@$parent->%leSQ->$text())
		    # reset lineedit value to "" empty string
		    @$parent->%leSQ->$setText("")
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		  else
		    return $false
		}
		
		privateimpl(@%lbS, keyPressEvent)
		{
		  if ($0 == "Del" || $0 == "Backspace")
		    @$emit("deletePressed")
		}
		
		# connect @%lbS deletePressed to @%btnSRm mousePressEvent
		objects.connect @%lbS deletePressed @%btnRm mousePressEvent
		
		# search REMOVE button, remove the search from %lbS listbox
		privateimpl(@%btnRm, mousePressEvent)
		{
		  # get selected lb entries, if null go false else remove each uid that is selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		    foreach(%uid, %selectedSQ)
		      @$parent->%lbS->$removeItem(%uid)
		  # update the hush searches array
		  @$parent->$setSearches()
		}
		
		# season/episode up & down buttons
		# SEASON UP
		privateimpl(@%btnSUp, mousePressEvent)
		{
		  %fn = "constructor::btnSUp::mousePressEvent"
		  # get selected lb entries, if null go false else increase season for each uid selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		  {
		    foreach(%uid, %selectedSQ)
		    {
		#      if (%G_hush->%debug) debug -c info: hush search string: @$parent->%lbS->$textAt(%uid)
		      # alter the season number up one
		      %newSearch = @$parent->$epChange(@$parent->%lbS->$textAt(%uid), season, up)
		      if (%newSearch != $false)
		      {
		#        if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
		        @$parent->%lbS->$changeItem(%newSearch, %uid)
		      }
		#      else
		#        if (%G_hush->%debug) debug -c info: @$parent->%lbS->$textAt(%uid) - no season info found, nothing changes
		    }
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		}
		
		# SEASON DOWN
		privateimpl(@%btnSDown, mousePressEvent)
		{
		  # get selected lb entries, if null go false else increase season for each uid selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		  {
		    foreach(%uid, %selectedSQ)
		    {
		#      if (%G_hush->%debug) debug -c info: hush search string: @$parent->%lbS->$textAt(%uid)
		      # alter the season number up one
		      %newSearch = @$parent->$epChange(@$parent->%lbS->$textAt(%uid), season, down)
		      if (%newSearch != $false)
		      {
		#	   if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
		        @$parent->%lbS->$changeItem(%newSearch, %uid)
		      }
		#      else
		#       if (%G_hush->%debug) debug -c info: @$parent->%lbS->$textAt(%uid) - no season info found, nothing changes
		    }
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		}
		
		# EPISODE UP
		privateimpl(@%btnEUp, mousePressEvent)
		{
		  # get selected lb entries, if null go false else increase season for each uid selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		  {
		    foreach(%uid, %selectedSQ)
		    {
		#      if (%G_hush->%debug) debug -c info: hush search string: @$parent->%lbS->$textAt(%uid)
		      # alter the episode number up one
		      %newSearch = @$parent->$epChange(@$parent->%lbS->$textAt(%uid), episode, up)
		      if (%newSearch != $false)
		      {
		#        if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
		        @$parent->%lbS->$changeItem(%newSearch, %uid)
		      }
		#      else
		#        if (%G_hush->%debug) debug -c info: @$parent->%lbS->$textAt(%uid) - no episode info found, nothing changes
		    }
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		}
		
		# EPISODE DOWN
		privateimpl(@%btnEDown, mousePressEvent)
		{
		  %fn = "constructor::btnEDown::mousePressEvent"
		  # get selected lb entries, if null go false else alter season/episode for each uid selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		  {
		    foreach(%uid, %selectedSQ)
		    {
		#      if (%G_hush->%debug) debug -c info: hush search string: @$parent->%lbS->$textAt(%uid)
		      # alter the episode number up one
		      %newSearch = @$parent->$epChange(@$parent->%lbS->$textAt(%uid), episode, down)
		      if (%newSearch != $false)
		      {
		#        if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
		        @$parent->%lbS->$changeItem(%newSearch, %uid)
		      }
		#      else
		#        if (%G_hush->%debug) debug -c info: @$parent->%lbS->$textAt(%uid) - no episode info found, nothing changes
		    }
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		}
		
		# EPISODE RESET
		privateimpl(@%btnEReset, mousePressEvent)
		{
		  %fn = "constructor::btnEReset::mousePressEvent"
		  # get selected lb entries, if null go false else alter season/episode for each uid selected
		  %selectedSQ = $rsort(@$parent->%lbS->$selectedItems())
		  if (%selectedSQ == $null)
		    return $false
		  else
		  {
		    foreach(%uid, %selectedSQ)
		    {
		#      if (%G_hush->%debug) debug -c info: hush search string: @$parent->%lbS->$textAt(%uid)
		      # alter the episode number reset to 01
		      %newSearch = @$parent->$epChange(@$parent->%lbS->$textAt(%uid), episode, reset)
		      if (%newSearch != $false)
		      {
		#        if (%G_hush->%debug) debug -c info: search string altered to: %newSearch
		        @$parent->%lbS->$changeItem(%newSearch, %uid)
		      }
		#      else
		#        if (%G_hush->%debug) debug -c info: @$parent->%lbS->$textAt(%uid) - no episode info found, nothing changes
		    }
		    # update the hush searches array
		    @$parent->$setSearches()
		  }
		}
		
		# exception lineedit mouse press
		privateimpl(@%leSExc, mousePressEvent)
		{
		  if (@$text() == "Enter search exception to add..." || @$text() == "")
		    @$setText("")
		}
		
		privateimpl(@%leSExc, keyPressEvent)
		{
		  if ($0 == "Return")
		    @$emit("enterPressed")
		}
		
		# connect %leSExc enterPressed to %btnSExcAdd mousePressEvent
		objects.connect @%leSExc enterPressed @%btnSExcAdd mousePressEvent
		
		# exception add button, add the exception in %leSExc lineedit to %lbSExc listbox
		privateimpl(@%btnSExcAdd, mousePressEvent)
		{
		  # check if text in %leSExc exists, add to %lbSExc if it does
		  if (@$parent->%leSExc->$text() != "")
		  {
		    @$parent->%lbSExc->$insertItem(@$parent->%leSExc->$text());  # move exception from lineedit to listbox
		    @$parent->%leSExc->$setText("");              # reset lineedit value to "" empty string
		    # update the hush search exceptions array
		    @$parent->$setSExceptions()
		  }
		  else
		    return $false
		}
		
		privateimpl(@%lbSExc, keyPressEvent)
		{
		  if ($0 == "Del" || $0 == "Backspace")
		    @$emit("deletePressed")
		}
		
		# connect @%lbSExc deletePressed to @%btnSExcRm mousePressEvent
		objects.connect @%lbSExc deletePressed @%btnSExcRm mousePressEvent
		
		# exception remove button, remove the exception from %lbSExc listbox
		privateimpl(@%btnSExcRm, mousePressEvent)
		{
		  # get selected lb entries, if null go false else remove each uid that is selected
		  %selectedExc = $rsort(@$parent->%lbSExc->$selectedItems())
		  if (%selectedExc == $null)
		    return $false
		  else
		    foreach(%uid, %selectedExc)
		      @$parent->%lbSExc->$removeItem(%uid)
		  # update the hush search exceptions array
		  @$parent->$setSExceptions()
		}
		
		# close event
		privateimpl($$, closeEvent)
		{
		#  if (%G_hush->%debug) debug -c info: closing searches widget
		}
	}
	
}

class("hush::queueeditor","widget")
{
	function refreshQueue(updates the queue editor information)
	{
		/* this function refreshes data shown in the download queue widget
		
		This function should be called when the entire download queue needs to be refreshed which will usually be when 
		the contents of the downloadHash changes. 
		
		It should not be called when sinlge rows of the download queue need updating (an xdccobject updates its info)
		You should use refreshItem for that.
		
		Dev-Notes
			propertiesSeen - declared and set in the queueeditor::constructor. This is an array that contains the xdccobject info names 
		 to display in the download queue widget
		*/
		
		# reset the listviewitem array
		for (%i = 0; %i < @%lviDownloads[]#; %i++)
		{
			delete -i @%lviDownloads[%i];
		}
		@%lviDownloads = $array;
		
		# check if downloadHash exists and is a hash
		if ($isSet(%G_hushDownloadHash) && $typeOf(%G_hushDownloadHash) == hash)
		{
			# check size of downloadHash
			if ($length(%G_hushDownloadHash) > 0)
			{
				# check if we have the downloadOrder array
				if ($isSet(%G_hush->%downloadOrder) && $typeOf(%G_hush->%downloadOrder) == array)
				{
					%qNum = 0;
					%stN = 0;
					for (%n = 0; %n < %G_hush->%downloadOrder[]#; %n++)
					{
						%searchTerm = $false
						%searchTerm = %G_hush->%downloadOrder[%n]
		#debug -c SearchTerm: %searchTerm
						if (%G_hushDownloadHash{%searchTerm}[]# > 0 && %searchTerm)
						{
							for (%i = 0; %i < %G_hushDownloadHash{%searchTerm}[]#; %i++)
							{
								# treeRoots is a hash that holds the qnum (index number) of the first xdccobject for each searchTerm in the 
								# downloadHash
								# the treeRoots values are used to create a tree structure in the download queue based on searchTerm values
								# so we can expand and collapse the download queue on a per searchTerm basis
								# subsequent xdccobjects in the download hash with matching searchTerms are the child of the first xdccobject 
								# in the listviewitem array
		
								# if this searchTerm doesn't have an entry in the treeRoot hash
								if (!$isSet(%treeRoots{%searchTerm})) 
								{
									# add this entry's qNum value to the treeRoots hash
									%treeRoots{%searchTerm} = %qNum
									# make this listviewitem have the listview object as parent
									@%lviDownloads[%qNum] = $new(listviewitem, @%lvQueue)
								}
								else
								{
									# make this listviewitem have the listviewitem corressponding by searchTerm as its parent
									@%lviDownloads[%qNum] = $new(listviewitem, @%lviDownloads[%treeRoots{%searchTerm}])
								}
								# set the lviDownloads qnum value in the xdccobject's info so we can access this widget later on to update it
								%G_hushDownloadHash{%searchTerm}[%i]->$setInfo(downloadQNum,%qNum)
								# propertiesSeen is declared and set in the queueeditor::constructor
								for (%p = 0; %p < @%propertiesSeen[]#; %p++)
								{
									%colOutput = @$parseColForOutput(%p,%searchTerm,%i)
									@%lviDownloads[%qNum]->$setText(%p, %colOutput)
								}
								%qNum++;
							}
							%stN++;
						}
					} 
					@%lblStatusLeft->$setText(%qNum packs found matching %stN search terms.)
				}
				else
				{
					if (%G_hush->%debug) {debug -c we have no downloadOrder array. check data and try again.;}
				}
			}
			else
			{
				if (%G_hush->%debug) {debug -c downloadHash size is 0 or less. Nothing to display in the Queue Editor.;}
			}
		}
		else
		{
			if (%G_hush->%debug) {debug -c downloadHash either does not exist or is not a hash. Nothing to display in Queue Editor;}
		}
		#debug -c returning from refreshQueue
		return;
	}
	
	function refreshItem(refreshes a single item or row in the download queue widget)
	{
		#debug -c we are in refreshItem, qNum: $0, st: $1, di: $2
		%qNum = $0
		%st = $1
		%di = $2
		
		# dev-note: we have to use isSet for the check here because we want 0 to be an acceptable value for the logic
		// refresh all seen info for this qnum
		for (%i = 0; %i < @%propertiesSeen[]#; %i++)
		{
			%colOutput = @$parseColForOutput(%i,%st,%di);
			@%lviDownloads[%qNum]->$setText(%i,%colOutput)
		}
	}
	
	function parseColForOutput(parses any column value for output to the download queue widget)
	{
		%p = $0
		%searchTerm = $1
		%i = $2
		
		%return = $false
		
		if ($isSet($2) && $isNumeric($2))
		{
			# use this switch case block to set any column specific things, eg: changing packSize from bytes to Mb and setting a tool tip
			switch(@%propertiesSeen[%p])
			{
				case(currentSpeed):
				{
					%return = $str.printf("?.2f",$($real(%G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p])) / 1048576)) "Mb/sec"
					break;
				}
				case(filesize):
				{
					%return = $(%G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p]) / 1048576) Mb
					break;
				}
				case(fileTotalSize):
				{
					%return = $(%G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p]) / 1048576) Mb
					break;
				}
				case(percentComplete):
				{
					%return = %G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p])\%
					break;
				}
				case(autoDownload):
				{
					%return = %G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p])
					if (%return)
						%return = Yes;
					else
						%return = No;
					break;
				}
				default:
				{
					%return = %G_hushDownloadHash{%searchTerm}[%i]->$getInfo(@%propertiesSeen[%p])
				}
			}	
		}
		else
		{
			if (%G_hush->%debug) {debug -c \$2 is not an integer. \$2 = $2 (cant parse the xdccobject info for update);}
		}
		return %return
	}
	
	function fnGetQueueColumnInt(returns the integer value of a column in the @%propertiesSeen array)
	{
		%debugMsg = ""
		%success = $false;
		if (!$isEmpty($0)) {%colName = $0;}
		
		if (%colName)
		{
			%success = %G_hush->%common->$fnArrayIterativeSearch(%colName, @%propertiesSeen, index)
			%debugMsg .= "\nfound column %colName at position %success"
		}
		else {%debugMsg .= "\nColumn Name (first argument) was not passed to the function. Check data and try again.";}
		
		if (%G_hush->%debug && $typeOf(%success) != boolean) {debug -c DEBUG: %debugMsg;}
		
		return %success;
		# dont forget to check the result in the calling function by TYPE as 0 is a valid return value! (check if the return type is bool or not)
	}
	
	function constructor(creates the elements of the queueeditor widget)
	{
		# queueeditor class for hush - builds the download queue window
		
		/*
			@%xdccObjectProperties - array - holds the names of all the properties an xdccobject can have
			@%propertiesTitle - hash - holds key => value pairs to convert xdccobject property names to column titles in the UI
			@%propertiesSeen - array - holds names of xdccobject properties we want to see in the UI, in the order they should appear 
			from left to right. Note: this array can be changed at runtime (hopefully) and should be loaded/saved to config file.
			@%defaultColWidth - int/number - default column width calculated by 90% of width of main widget divided by number of items in @%propertiesSeen
		*/
		
		
		@$setGeometry(0,0,1000,300)
		@$setWindowTitle("Hush::Download Queue")
		@$centerToScreen()
		@$setFocus()
		
		@%xdccObjectProperties = $array(attempts, autoDownload, averageSpeed, botName, channelName, currentSpeed, extractFile, extractInner, filesize, ircContext, mediaCategory, networkName, packGets, packName, packNum, packSize, percentComplete, searchTerm, sendStyle, sessionID, status)
		@%propertiesTitle = $hash(attempts,Attempts, autoDownload,Automatic, averageSpeed,Avg. Speed, botName,Bot, channelName,Channel, currentSpeed,Speed, extractFile,Extracted File, extractInner,Extracted Inner, filesize,Local Size, fileTotalSize,Total Size, ircContext,IRC Context, mediaCategory,Category, networkName,Network, packGets,Pack Gets, packName,Pack Name, packNum,Pack Num, packSize,Pack Size, percentComplete,Downloaded, searchTerm,Search Term, sendStyle,Style, sessionID,DCC ID, status,Status)
		@%propertiesSeen = $array(autoDownload, searchTerm, packName, channelName, botName, mediaCategory, fileTotalSize, filesize, currentSpeed, percentComplete, status)
		@%defaultColWidth = $((@$width * 0.9) / $length(@%propertiesSeen));
		
		### init child widgets for Download Queue
		
		# main layout
		@%l0 = $new(layout, $$)
		@%l0->$setSpacing(3)
		
		# title label
		@%lblTitle = $new(label, $$)
		@%lblTitle->$setText("<b>Download Queue</b>")
		@%lblTitle->$settooltip("Display and interect with the download queue here")
		@%lblTitle->$setAlignment(Left)
		
		@%hboxButtons = $new(hbox, $$, "buttons hbox")
		@%hboxButtons->$setSpacing(3)
		
		# button bin
		@%btnBin = $new(button, @%hboxButtons, "btnBin")
		@%btnBin->$setImage($file.localdir("pics/Hush/bin.png"))
		@%btnBin->$setTooltip("Remove selected item from download queue")
		@%btnBin->$setMaximumWidth(40)
		
		# button move up
		@%btnMoveUp = $new(button, @%hboxButtons, "btnMoveUp")
		@%btnMoveUp->$setToolTip("Move the selected search term up the list in priority")
		@%btnMoveUp->$setMaximumWidth(40)
		@%btnMoveUp->$setText("")
		
		# button move down
		@%btnMoveDown = $new(button, @%hboxButtons, "btnMoveDown")
		@%btnMoveDown->$setToolTip("Move the selected search term down the list in priority")
		@%btnMoveDown->$setMaximumWidth(40)
		@%btnMoveDown->$setText("")
		
		### TEMPORARY DEV button set to failed
		@%btnSetFailed = $new(button, @%hboxButtons, "btnSetFailed")
		@%btnSetFailed->$setToolTip("Temporary Dev Button - set pack's status to Failed and try next download")
		@%btnSetFailed->$setMaximumWidth(40)
		@%btnSetFailed->$setText("")
		
		### TEMPORARY DEV button decrement active transfers
		@%btnDecAutos = $new(button, @%hboxButtons, "btnDecAutos")
		@%btnDecAutos->$setToolTip("Temporary Dev Button - decrement active auto transfers value by 1")
		@%btnDecAutos->$setMaximumWidth(40)
		@%btnDecAutos->$setText("A;")
		
		### TEMPORARY DEV button call xdcc::doNextAutoDownload
		@%btnCallNextAuto = $new(button, @%hboxButtons, "btnCallNextAuto")
		@%btnCallNextAuto->$setToolTip("Temporary Dev Button - do next auto download")
		@%btnCallNextAuto->$setMaximumWidth(40)
		@%btnCallNextAuto->$setText("")
		
		@%hboxButtons->$addStretch(1)
		
		# listview area (shows all the download queue details)
		@%lvQueue = $new(listview, $$)
		@$buildListView
		
		# status bar label left
		@%lblStatusLeft = $new(label, $$)
		@%lblStatusLeft->$setText(" ")
		
		# populate child widgets
		@$refreshQueue
		
		# do layout of child widgets
		
		
		@%l0->$addMultiCellWidget(@%lblTitle, 0,0,0,0)
		@%l0->$addMultiCellWidget(@%hboxButtons, 1,1,0,0)
		@%l0->$addMultiCellWidget(@%lvQueue, 2,2,0,0)
		@%l0->$addMultiCellWidget(@%lblStatusLeft, 3,3,0,0)
		
		objects.connect @%btnBin clicked $$ buttonClickedHandler
		objects.connect @%btnMoveDown clicked $$ buttonClickedHandler
		objects.connect @%btnMoveUp clicked $$ buttonClickedHandler
		objects.connect @%btnSetFailed clicked $$ buttonClickedHandler
		objects.connect @%btnDecAutos clicked $$ buttonClickedHandler
		objects.connect @%btnCallNextAuto clicked $$ buttonClickedHandler
	}
	
	function buttonClickedHandler(Handles the events thrown by the buttons of the queueeditor object.)
	{
		/* this function handles any clicked event thrown by the buttons of the queue editor
		
		it detects which object has thrown the event by looking at $$->$signalSender->$name
		NOTE: for it to know which object sent the signal event, your child widgets _MUST_ have a name that matches a value in the 
		switch ... case sections below.
		You name a widget by setting the third parameter when you use $new() to create the child widget object in the constructor.
		
		How to use/alter the download item you have selected in the queue:
		
			When you click a button on the download queue editor window, the selected item in the listview widget will be held
			in %selectedItem. 
			%selectedItem is an array. There will only be one element in the array: %selectedItem[0].
			The value of that array element is a listviewitem object.
			The listviewitem object can be altered using %selectedItem[0]->$setText(column:int,text:string) or any other 
			listviewitem class functions.
			Column integer values can be accessed via the %G_hush->%queueeditor->%propertiesSeen array where the array index is the 
			column integer to the column name.
			Use the @$fnGetQueueColumnInt(columnName:string) function to find the column => int pairing: 
		*/
		
		%btnName = $$->$signalSender->$name
		%changed = $false
		%debugMsg = ""
		%newOrderArray = $array
		%selectedItem = $$->%lvQueue->$selectedItems()
		#debug -c the button %btnName was pressed
		
		if (%selectedItem)
		{
			%dbgMsg .= "\nselectedItem was: %selectedItem[0]->$text(1)";
			%searchTerm = %selectedItem[0]->$text(1)
			%debugMsg .= "\nsearchTerm = %searchTerm"
			%origIndex = %G_hush->%common->$fnArrayIterativeSearch(%searchTerm,%G_hush->%downloadOrder,index)
			%indexAfter = $(%origIndex + 1);
			%indexBefore = $(%origIndex - 1);
			# dev-note: the following check MUST check the type of %origIndex because the arraysearch function can return 0 as a valid value
			if ($typeOf(%origIndex) != boolean)
			{
				switch(%btnName)
				{
					case (btnBin)
					{
						# delete select items from downloadHash
						if ($isSet(%G_hushDownloadHash{%searchTerm}))
						{
							# we need to check if any of this searchTerm has an active transfer before we remove it
							# for now I am just going to delete it to get the function going
							%G_hushDownloadHash{%searchTerm} = $null
							# find which index this searchTerm is in the downloadOrder array
							%i = %G_hush->%common->$fnArrayIterativeSearch(%searchTerm, %G_hush->%downloadOrder)
							%G_hush->%downloadOrder[%i] = $null
							%G_hush->%downloadOrder = %G_hush->%common->$fnArrayRemoveEmptyValues(%G_hush->%downloadOrder)
							%changed = $true
						}
						else {%debugMsg .= "\ncase: %btnName: searchTerm: %searchTerm was not found in the downloadHash.";}
						# refresh the queue
						
						break
					}
					case (btnMoveDown)
					{
						# if origIndex is the same as downloadOrder array size it means the item we're trying to move is already at the bottom
						if (%origIndex == %G_hush->%downloadOrder[]#) {break;}
						# increment the position of the selectedItem's searchTerm in the downloadOrder array
						for (%i = 0; %i < %G_hush->%downloadOrder[]#; %i++)
						{
							if (%i == %origIndex)
							{
								%newOrderArray[%origIndex] = %G_hush->%downloadOrder[%indexAfter]
								%newOrderArray[%indexAfter] = %G_hush->%downloadOrder[%origIndex]
								%i++
							}
							else
							{
								%newOrderArray[%i] = %G_hush->%downloadOrder[%i]
							}
						}
						%changed = $true
						break
					}
					case (btnMoveUp)
					{
						# if origIndex is 0 it means the item we're trying to move is already at the top
						if (%origIndex == 0) {break;}
						# decrement the position of the selectedItem's searchTerm in the downloadOrder array
						for (%i = 0; %i < %G_hush->%downloadOrder[]#; %i++)
						{
							if (%i == %indexBefore)
							{
								%newOrderArray[%origIndex] = %G_hush->%downloadOrder[%indexBefore]
								%newOrderArray[%indexBefore] = %G_hush->%downloadOrder[%origIndex]
								%i++
							}
							else
							{
								%newOrderArray[%i] = %G_hush->%downloadOrder[%i]
							}
						}
						%changed = $true
						break
					}
					case (btnSetFailed)
					{
						%colInt = $false
						%colInt = @$fnGetQueueColumnInt(Status)
						if ($typeOf(%colInt) != boolean)
						{
							%botName = %selectedItem[0]->$text(@$fnGetQueueColumnInt(botName))
							%packName = %selectedItem[0]->$text(@$fnGetQueueColumnInt(packName))
							%thisDL = %G_hush->$searchDownloadHash(%botName,%packName)
							%thisDL = $str.split(|||,%thisDL,2)
							%st = %thisDL[0]
							%di = %thisDL[1]
							%qNum = %G_hushDownloadHash{%st}[%di]->$getInfo(downloadQNum)
							%G_hushDownloadHash{%st}[%di]->$setInfo(status,Failed)
							# also check for and remove any timer that is for this download
							@$refreshItem(%qNum, %st, %di)
						}
						else {%debugMsg .= "\nfnGetColumnInt(Status) returned boolean type value: %colInt which means it failed to find Status in the propertiesSeen array. Are you trying to alter a column name that isnt being shown?";}
						break
					}
					default:
					{
						break
					}
				}
			}
			else {%debugMsg .= "\ncase: %btnName: origIndex was %origIndex\. hush::common::fnArrayIterativeSearch returned null. The searchTerm: $k(14)%searchTerm$k() was not found in the downloadOrder array. Check data and try again.";}
		}
		else
		{
			%debugMsg .= "no item was selected"
		}
		
		# dev note: these buttons are a seperate switch/case block because they do not require a selected item to work
		switch(%btnName)
		{
			case (btnDecAutos)
			{
				%debugMsg .= "\nDecremented Active Auto Downloads by 1";
				%G_hushLive{iTransfersActive}--;
				break
			}
			case (btnCallNextAuto)
			{
				%debugMsg .= "\nUser requested to attempt next auto download";
				xdcc::doNextAutoDownload
				break
			}
			default:
			{
				break
			}
		}
		
		if (%changed)
		{
			if (%newOrderArray[]# > 0)
			{
				%debugMsg .= "\nSetting the new downloadOrder array"
				%G_hush->%downloadOrder = %newOrderArray
			}
			%debugMsg .= "\nThe download queue was altered by %btnName so refreshing the queue"
			%G_hush->%queueeditor->$refreshQueue()
		}
		
		if (%G_hush->%debug && %debugMsg != $false)
		{
			debug -c %debugMsg
		}
	}
	
	function buildListView(this function builds the listview object for the download queue widget)
	{
		foreach (%prop, @%propertiesSeen)
		{
			@%lvQueue->$addColumn(@%propertiesTitle{%prop},@%defaultColWidth)
		}
		return $true
	}
	
}

class("hush::options","widget")
{
	function slotTransfersDCCTimeoutChange(handles when the value changes in the transfers DCC Timeout spinbox)
	{
		# this function is a slot to catch the valueChanged signal on a spinbox
		
		# if (%G_hush->%debug) {debug -c new value: $0;}
		
		option uintDccSocketTimeout $0
	}
	
	function fnISReset(resets the instant search database)
	{
		# this function deletes the instant search database from disk and creates it again.
		
		if (!$objects.exists(%G_hush))
			debug -c Somehow you called a function from an object that doesn't exist. Restarting KVIrc is probably the best option.
		else
		{
			%G_hush->$dbDisconnect();
			%G_hush->$dbCreate($true);
			%G_hush->$dbConnect();
			dialog.message -b ("Notice", "Instant Search database has been reset.", information, "OK") {}
		}
	}
	
	function fileIO(get the user to set a filename - $0 dialog type; $1 dialog caption; $2 default filename; $3 filetype mask; $4 hush internal type)
	{
		# options function to get filename from user
		
		%success = $false
		dialog.file -b ($0, $1, $2, $3, $4)
		{
			# note: $0 here will hold the value returned from the dialog.file call. if it is null, we will
			# assume that the user cancelled the action of exporting settings because the dialog won't
			# let the user return an empty string
			# magic parameters (see kvirc doc > commands > dialog.file) of this function are now in the 
			# magic values: $1 onwards
			if ($0 != "")
			{
				# note that we must use the global variable names here
				# the scope of the dialog callback code is not within our class object!
				if (%G_hush->%debug) debug -c info: filename for current operation '$1' = $0
		
				if ($1 == "hushESTF")
				{
					# export settings to file $0 (calls hush::main::$configSave)
					%G_hush->$configSave($0, searches, %G_hushSearches)
					%G_hush->$configSave($0, exceptions, %G_hushSExceptions)
					%G_hush->$configSave($0, options, %G_hushOptions)
					%G_hush->$configSave($0, channels, %G_hushWatchChannels)
					dialog.message -b ("Notice", "Settings export complete.", information, "OK") {}
					%success = $true
				}
				else if ($1 == "hushISFF")
				{
					# import settings from file $0 (calls hush::main::$configLoad)
					%G_hushSearches = %G_hush->$configLoad($0, searches)
					%G_hushSExceptions = %G_hush->$configLoad($0, exceptions)
					%G_hushOptions = %G_hush->$configLoad($0, options, hash)
					%G_hushWatchChannels = %G_hush->$configLoad($0, channels)
					dialog.message -b ("Notice", "Settings import complete.", information, "OK") {}
					%success = $true
				}
				# this func requires a 'hush token' value, otherwise return doing nothing
			}
			else
			{
				# if we get back no filename it means the user clicked cancel on the dialog. so just do debug message, no need for a warning dialog
				if (%G_hush->%debug) {debug -c Ineresting: no filename returned. User probably clicked Cancel button.;}
			}
		}
		
		return %success
	}
	
	function constructor(Initializes widgets for the Options setting window)
	{
		# options class for hush - builds the Options settings window
		
		@$setGeometry(0,0,330,300)
		@$setWindowTitle("Hush::Settings::Options")
		@$centerToScreen()
		@$setFocus()
		
		### init child widgets for Settings::Options
		
		# tab widget
		@%tabw = $new(tabwidget, $$)
		
		# main layout
		@%l0 = $new(layout, $$)
		@%l0->$setSpacing(3)
		//@%l0->$setRowStretch(1,50)
		//@%l0->$setRowStretch(2,2)
		//@%l0->$setRowStretch(3,2)
		//@%l0->$setRowStretch(4,2)
		//@%l0->$setRowStretch(5,2)
		
		# title label
		@%lblTitle = $new(label, $$)
		@%lblTitle->$setText("<b>Options</b>")
		@%lblTitle->$settooltip("Toggle and change various options here.")
		@%lblTitle->$setAlignment(Left)
		
		### Base Tab ###
		@%wgtPageBasic = $new(widget, 0, "options Basic Page Widget for tab")
		@%lPageBasic = $new(layout, @%wgtPageBasic)
		@%lPageBasic->$setSpacing(2)
		
		# create child widgets
		# label heading - general
		@%lblHeadingGeneral = $new(label, @%wgtPageBasic)
		@%lblHeadingGeneral->$setText("<b>General</b>")
		@%lblHeadingGeneral->$setAlignment(Left)
		# label for lineedit (so user knows what the line edit is for)
		@%lblFCW = $new(label, @%wgtPageBasic)
		@%lblFCW->$setText("Found Content Window Name: ")
		//@%lblFCW->$setMinimumWidth(350)
		# lineedit for found content window name
		@%leFCW = $new(lineedit, @%wgtPageBasic)
		@%leFCW->$setToolTip("Name for the window that will display any content Hush finds on offer.<br/>Look for the ninja that will appear in the channel list!")
		//@%leFCW->$setMinimumWidth(100)
		# checkbox for SSL send option
		@%cbSSL = $new(checkbox, @%wgtPageBasic)
		@%cbSSL->$setText("SSL Send Option in Found Content Window")
		@%cbSSL->$setTooltip("Display SSL DCC send links in the FCW. SSL for automatic downloads is in the Trasnfers tab.<br/>SSLDCC is only supported by mg afaik.")
		
		# label heading - noise
		@%lblHeadingNoise = $new(label, @%wgtPageBasic)
		@%lblHeadingNoise->$setText("<br/><b>Noise</b>")
		@%lblHeadingNoise->$setAlignment(Left)
		# checkbox for under the radar
		@%cbNoiseNone = $new(checkbox, @%wgtPageBasic)
		@%cbNoiseNone->$setText("Under the Radar")
		@%cbNoiseNone->$setTooltip("Tick this to prevent Hush from giving any output at all.")
		# checkbox for watched channels silence toggle
		@%cbSWC = $new(checkbox, @%wgtPageBasic)
		@%cbSWC->$setText("Silence Watched Channels")
		@%cbSWC->$setTooltip("Your watched channels will be 'silenced'.<br/>Hush will still see the pack announcements but you won't.")
		# checkbox for ZNC Push option 
		@%cbZNCPush = $new(checkbox, @%wgtPageBasic)
		@%cbZNCPush->$setText("ZNC Push Notifications")
		@%cbZNCPush->$setTooltip("Push found search matches via ZNC Push.<br/>ZNC server with configured ZNC Push module is required.")
		# checkbox for ZNC Push prevent *push query window 
		@%cbZNCPreventQuery = $new(checkbox, @%wgtPageBasic)
		@%cbZNCPreventQuery->$setText("Prevent ZNC *push query window appearing")
		@%cbZNCPreventQuery->$setTooltip("Prevents the ZNC *push query window from opening in the channel list.")
		# button for exporting settings to file
		@%btnESTF = $new(button, @%wgtPageBasic)
		@%btnESTF->$setText("Export Settings")
		@%btnESTF->$setTooltip("Save your Hush settings to file on disk.")
		# button for importing settings from file
		@%btnISFF = $new(button, @%wgtPageBasic)
		@%btnISFF->$setText("Import Settings")
		@%btnISFF->$setTooltip("Load your Hush settings from file on disk.")
		# button to reset haystack
		@%btnCHS = $new(button, @%wgtPageBasic)
		@%btnCHS->$setText("Clear Haystack")
		@%btnCHS->$setTooltip("Clears the smart mode haystack.<br/>Previously found items will appear again in the found content window.")
		
		### populate child widgets from settings values, else use defaults
		# populate Found Content Window name if no value is found
		if (%G_hushOptions{"FCW"} != "") { @%leFCW->$setText(%G_hushOptions{"FCW"}); }
		else { @%leFCW->$setText("Hush"); }
		# populate silence watched channels checkbox, default to ticked (true)
		if ($isSet(%G_hushOptions{"NoiseNone"})) { @%cbNoiseNone->$setChecked(%G_hushOptions{"NoiseNone"}); }
		else { @%cbNoiseNone->$setChecked($true); }
		# populate silence watched channels checkbox, default to ticked (true)
		if ($isSet(%G_hushOptions{"SWC"})) { @%cbSWC->$setChecked(%G_hushOptions{"SWC"}); }
		else { @%cbSWC->$setChecked($true); }
		# populate SSL mode checkbox, default to ticked (true)
		if ($isSet(%G_hushOptions{"SSL"})) { @%cbSSL->$setChecked(%G_hushOptions{"SSL"}); }
		else { @%cbSSL->$setChecked($true); }
		# populate ZNC Push checkbox, default to unticked (false)
		if ($isSet(%G_hushOptions{"ZNCPush"})) { @%cbZNCPush->$setChecked(%G_hushOptions{"ZNCPush"}); }
		else { @%cbZNCPush->$setChecked($false); }
		# populate ZNC Prevent *push query checkbox, default to unticked (false)
		if ($isSet(%G_hushOptions{"ZNCPreventQuery"})) { @%cbZNCPreventQuery->$setChecked(%G_hushOptions{"ZNCPreventQuery"}); }
		else { @%cbZNCPreventQuery->$setChecked($false); }
		
		
		@%lPageBasic->$setColumnStretch(0,1)
		@%lPageBasic->$setColumnStretch(1,0)
		@%lPageBasic->$setColumnStretch(2,1)
		@%lPageBasic->$setColumnStretch(3,0)
		
		@%lPageBasic->$setRowStretch(0,0)
		@%lPageBasic->$setRowStretch(1,1)
		@%lPageBasic->$setRowStretch(2,1)
		@%lPageBasic->$setRowStretch(3,0)
		@%lPageBasic->$setRowStretch(4,1)
		@%lPageBasic->$setRowStretch(5,1)
		@%lPageBasic->$setRowStretch(6,1)
		@%lPageBasic->$setRowStretch(7,1)
		@%lPageBasic->$setRowStretch(8,1)
		@%lPageBasic->$setRowStretch(9,1)
		
		
		# layout for Tab: Basic Page
		@%lPageBasic->$addMultiCellWidget(@%lblHeadingGeneral, 0,0,0,3)
		@%lPageBasic->$addMultiCellWidget(@%lblFCW, 1,1,0,0)
		@%lPageBasic->$addMultiCellWidget(@%leFCW, 1,1,1,3)
		@%lPageBasic->$addMultiCellWidget(@%cbSSL, 2,2,0,3)
		@%lPageBasic->$addMultiCellWidget(@%lblHeadingNoise, 3,3,0,3)
		@%lPageBasic->$addMultiCellWidget(@%cbNoiseNone, 4,4,0,3)
		@%lPageBasic->$addMultiCellWidget(@%cbSWC, 5,5,0,3)
		@%lPageBasic->$addMultiCellWidget(@%cbZNCPush, 6,6,0,3)
		@%lPageBasic->$addMultiCellWidget(@%cbZNCPreventQuery, 7,7,0,3)
		@%lPageBasic->$addMultiCellWidget(@%btnESTF, 8,8,0,1)
		@%lPageBasic->$addMultiCellWidget(@%btnISFF, 8,8,2,3)
		@%lPageBasic->$addMultiCellWidget(@%btnCHS, 9,9,0,3)
		
		### Transfers Tab ###
		@%wgtPageTransfers = $new(widget, 0, "options Transfer Widget for tab")
		@%lPageTransfers = $new(layout, @%wgtPageTransfers)
		
		# transfers child widgets
		# label for DCC timeout
		@%lblTransfersDCCTimeout = $new(label, @%wgtPageTransfers)
		@%lblTransfersDCCTimeout->$setText("DCC Timeout: ")
		@%lblTransfersDCCTimeout->$setToolTip("Defines the amount of time in seconds before an inactive DCC connection will timeout.<br/><b>Note:</b> This directly alters the KVIrc setting <i>uintDccSocketTimeout</i> found in Settings -&gt; Configure KVIrc -&gt; DCC -&gt; Advanced.<br/>This value should be slightly bigger than the timeout setting that bots have which is usually 180 seconds.<br/>Recommended value: 190")
		# lineedit for DCC timeout - dev note: this alters the KVIrc option uintDccSocketTimeout value directly
		@%sbTransfersDCCTimeout = $new(spinbox, @%wgtPageTransfers)
		@%sbTransfersDCCTimeout->$setSuffix(" seconds")
		@%sbTransfersDCCTimeout->$setMinValue(1)
		@%sbTransfersDCCTimeout->$setMaxValue(600)
		@%sbTransfersDCCTimeout->$setValue($option(uintDccSocketTimeout))
		@%sbTransfersDCCTimeout->$setLineStep(10)
		
		# auto download toggle
		@%chbTransfersAutoToggle = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoToggle->$setText(Automatic downloads)
		@%chbTransfersAutoToggle->$setToolTip("Toggle on/off if auto downloads should be done when a passive search is found.")
		# ssl for auto download toggle
		@%chbTransfersSSLAuto = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersSSLAuto->$setText(Use SSL for automatic downloads by default)
		@%chbTransfersSSLAuto->$setToolTip("Toggle on/off if auto downloads should ask for SSLDCC by default.<br/>Bots that do not support SSL will send back a query notice saying the command is unsupported.<br/>This setting affects auto-downloads only.")
		# detect bots that don't support SSL and request without SSL toggle
		@%chbTransfersNoSSLOK = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersNoSSLOK->$setText(Allow non-SSL for automatic downloads)
		@%chbTransfersNoSSLOK->$setToolTip("Toggle on/off if auto downloads should ever request without SSL.<br/>Bots that do not support SSL are logged by Hush. If you want to allow automatic downloads using non-SSL transfer, tick this option. If this option is unticked, bots that do not support SSL will be ignored by Hush's automatic download system.<br/>This setting affects auto-downloads only.")
		# label for max transfers
		@%lblTransfersMaxT = $new(label, @%wgtPageTransfers)
		@%lblTransfersMaxT->$setText("Maximum Auto-Downloads: ")
		@%lblTransfersMaxT->$setToolTip("Maximum number of auto-downloads Hush will start")
		# auto stop transfer if the filename isnt in the download hash
		@%chbTransfersAutoStopWrongFileToggle = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoStopWrongFileToggle->$setText(Stop download if filename is wrong)
		@%chbTransfersAutoStopWrongFileToggle->$setToolTip("Toggle on/off automatic stopping of a download if the filename is wrong.<br/>This option should only be used if you exclusively use Hush to get files as it will block transfers Hush doesn't know about.<br/>You can toggle it off if you want to allow unknown downloads.")
		# auto stop transfer if the bot is a passive bot (port 0 DCC)
		@%chbTransfersAutoStopPassiveToggle = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoStopPassiveToggle->$setText(Stop download from passive bots)
		@%chbTransfersAutoStopPassiveToggle->$setToolTip("Toggle on/off automatic stopping of a download if the bot is a passive bot (Port 0 DCC transfer).<br/>This option will automatically cancel a Hush download if it detects it is from a passive mode bot.")
		# maximum number of transfers hush can start
		@%sbTransfersMaxTransfers = $new(spinbox, @%wgtPageTransfers)
		@%sbTransfersMaxTransfers->$setToolTip("Maximum number of auto-downloads Hush will start")
		@%sbTransfersMaxTransfers->$setSuffix(" at any given time")
		@%sbTransfersMaxTransfers->$setMinValue(1)
		@%sbTransfersMaxTransfers->$setMaxValue(10)
		@%sbTransfersMaxTransfers->$setValue(2)
		@%sbTransfersMaxTransfers->$setLineStep(1)
		# retry on failed download
		@%chbTransfersRetryToggle = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersRetryToggle->$setText(Retry download on transfer failure)
		@%chbTransfersRetryToggle->$setToolTip("Toggle on/off retry a pack if it fails to download.")
		# label for max transfer retries
		@%lblTransfersMaxR = $new(label, @%wgtPageTransfers)
		@%lblTransfersMaxR->$setText("Maximum number of retries: ")
		# max number of re-request retries
		@%sbTransfersMaxRetries = $new(spinbox, @%wgtPageTransfers)
		@%sbTransfersMaxRetries->$setToolTip("Maximum number of times to retry a failed download.<br/>Recommended max: 3")
		@%sbTransfersMaxRetries->$setSuffix(" times")
		@%sbTransfersMaxRetries->$setMinValue(0)
		@%sbTransfersMaxRetries->$setMaxValue(10)
		@%sbTransfersMaxRetries->$setValue(3)
		@%sbTransfersMaxRetries->$setLineStep(1)
		@%lblTransfersCompletion = $new(label, @%wgtPageTransfers)
		@%lblTransfersCompletion->$setText("<hr/><b>On Download Completion</b>")
		@%lblTransfersCompletion->$setTooltip("The settings below affect how Hush behaves when a download is completed.")
		# increment tv show episodes automatically toggle
		@%chbTransfersAutoEpUp = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoEpUp->$setText(Automatically increment TV show episodes in passive searches)
		@%chbTransfersAutoEpUp->$setToolTip("Toogle on/off automatic incrementing of TV show episodes in passive searches list after they are automatically downloaded.")
		# delete search term after successful transfer if not episode toggle
		@%chbTransfersRmSearchTerm = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersRmSearchTerm->$setText(Remove search term after successful transfer)
		@%chbTransfersRmSearchTerm->$setToolTip("Toogle on/off automatic removal of search term from passive searches when they are automatically downloaded.<br/><b>Note:</b> This will only occur if the search term is NOT found to have an episode value in it. TV episodes will not be auto-removed from Searches.")
		# display message when transfer is complete
		@%chbTransfersDoneMsg = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersDoneMsg->$setText(Display messages when a transfer completes)
		@%chbTransfersDoneMsg->$setTooltip("Toggle on/off whether Hush should output a message about when a transfer finishes.<br/>This includes both failed and successful transfers, and will send a message via ZNC if the ZNC option is ticked in Basic settings.")
		# automatic archive extraction on complete transfer
		@%chbTransfersAutoExtract = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoExtract->$setEnabled($false)
		@%chbTransfersAutoExtract->$setText("Automatically extract archives (TAR & RAR files) [doesn't actually work in this version]")
		@%chbTransfersAutoExtract->$setTooltip("Toggle on/off whether Hush should automatically extract TAR & RAR files on completed download.")
		# automatic move file to library
		@%chbTransfersAutoMove = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoMove->$setText("Automatically move media files to Library location [only works on Windows OS at the moment]")
		@%chbTransfersAutoMove->$setTooltip("Toggle on/off whether Hush should automatically move media files to corressponding Library location on completed download.")
		# automatic update kodi devices
		@%chbTransfersAutoMCUpdate = $new(checkbox, @%wgtPageTransfers)
		@%chbTransfersAutoMCUpdate->$setText("Automatically update Media Centre devices")
		@%chbTransfersAutoMCUpdate->$setTooltip("Toggle on/off if Hush should send a video library update request to your configured media devices. See Media Centre tab to configure your devices.")
		
		# populate child widgets of Transfers tab
		
		if (%G_hushOptions{"TransfersRetryToggle"} != "") { @%chbTransfersRetryToggle->$setChecked(%G_hushOptions{"TransfersRetryToggle"}); }
		else { @%chbTransfersRetryToggle->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoToggle"} != "") { @%chbTransfersAutoToggle->$setChecked(%G_hushOptions{"TransfersAutoToggle"}); }
		else { @%chbTransfersAutoToggle->$setChecked($true); }
		if (%G_hushOptions{"TransfersSSLAuto"} != "") { @%chbTransfersSSLAuto->$setChecked(%G_hushOptions{"TransfersSSLAuto"}); }
		else { @%chbTransfersSSLAuto->$setChecked($true); }
		if (%G_hushOptions{"TransfersNoSSLOK"} != "") { @%chbTransfersNoSSLOK->$setChecked(%G_hushOptions{"TransfersNoSSLOK"}); }
		else { @%chbTransfersNoSSLOK->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoStopWrongFile"} != "") { @%chbTransfersAutoStopWrongFileToggle->$setChecked(%G_hushOptions{"TransfersAutoStopWrongFile"}); }
		else { @%chbTransfersAutoStopWrongFileToggle->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoStopPassive"} != "") { @%chbTransfersAutoStopPassiveToggle->$setChecked(%G_hushOptions{"TransfersAutoStopPassive"}); }
		else { @%chbTransfersAutoStopPassiveToggle->$setChecked($true); }
		if (%G_hushOptions{"TransfersMaxRetries"} != "") { @%sbTransfersMaxRetries->$setValue(%G_hushOptions{"TransfersMaxRetries"}); }
		else { @%sbTransfersMaxRetries->$setValue(3); }
		if (%G_hushOptions{"TransfersMaxTransfers"} != "") { @%sbTransfersMaxTransfers->$setValue(%G_hushOptions{"TransfersMaxTransfers"}); }
		else { @%sbTransfersMaxTransfers->$setValue(2); }
		if (%G_hushOptions{"TransfersAutoEpUp"} != "") { @%chbTransfersAutoEpUp->$setChecked(%G_hushOptions{"TransfersAutoEpUp"}); }
		else { @%chbTransfersAutoEpUp->$setChecked($true); }
		if (%G_hushOptions{"TransfersRmSearchTerm"} != "") { @%chbTransfersRmSearchTerm->$setChecked(%G_hushOptions{"TransfersRmSearchTerm"}); }
		else { @%chbTransfersRmSearchTerm->$setChecked($true); }
		if (%G_hushOptions{"TransfersDoneMsg"} != "") { @%chbTransfersDoneMsg->$setChecked(%G_hushOptions{"TransfersDoneMsg"}); }
		else { @%chbTransfersDoneMsg->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoExtract"} != "") { @%chbTransfersAutoExtract->$setChecked(%G_hushOptions{"TransfersAutoExtract"}); }
		else { @%chbTransfersAutoExtract->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoMove"} != "") { @%chbTransfersAutoMove->$setChecked(%G_hushOptions{"TransfersAutoMove"}); }
		else { @%chbTransfersAutoMove->$setChecked($true); }
		if (%G_hushOptions{"TransfersAutoMCUpdate"} != "") { @%chbTransfersAutoMCUpdate->$setChecked(%G_hushOptions{"TransfersAutoMCUpdate"}); }
		else { @%chbTransfersAutoMCUpdate->$setChecked($true); }
		
		# layout for transfers page
		@%lPageTransfers->$addMultiCellWidget(@%lblTransfersDCCTimeout, 0,0,0,0)
		@%lPageTransfers->$addMultiCellWidget(@%sbTransfersDCCTimeout, 0,0,1,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoToggle, 1,1,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersSSLAuto, 2,2,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersNoSSLOK, 3,3,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoStopWrongFileToggle, 4,4,0,0)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoStopPassiveToggle, 5,5,0,0)
		@%lPageTransfers->$addMultiCellWidget(@%lblTransfersMaxT, 6,6,0,0)
		@%lPageTransfers->$addMultiCellWidget(@%sbTransfersMaxTransfers, 6,6,1,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersRetryToggle, 7,7,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%lblTransfersMaxR, 8,8,0,0)
		@%lPageTransfers->$addMultiCellWidget(@%sbTransfersMaxRetries, 8,8,1,1)
		@%lPageTransfers->$addMultiCellWidget(@%lblTransfersCompletion, 9,9,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoEpUp, 10,10,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersRmSearchTerm, 11,11,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersDoneMsg, 12,12,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoExtract, 13,13,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoMove, 14,14,0,1)
		@%lPageTransfers->$addMultiCellWidget(@%chbTransfersAutoMCUpdate, 15,15,0,1)
		
		### Transfer Priority Tab ###
		@%wgtPageTransferPriority = $new(widget, 0, "options Transfer Priority Widget for tab")
		@%lPageTransferPriority = $new(layout, @%wgtPageTransferPriority)
		@%lPageTransferPriority->$setSpacing(10)
		
		# transfers child widgets
		# label for user help
		@%lblTPHelp = $new(label, @%wgtPageTransferPriority)
		@%lblTPHelp->$setText("<b>Transfer Priority</b><br/><br/>Transfer priorities for automatic downloads can be adjusted here.<br/><br/>Hush will make decisions about which bot to automatically download from. By default, it gives priority to either Speed or Success.<ul><li><b>Speed</b> - Give priority to bots that have the best average transfer speed.<li/><li><b>Success</b> - Give priority to bots that have the best transfer success rate.</li></ul>Add an additional layer of priority by enabling <b>Channel</b> priority. The Channel setting lets you tell Hush which channel(s) you prefer it to get content from.<br/><br/>Hover your mouse on the settings below to see additional help.<br/><hr width=1/>")
		
		# label for left side of slider (speed)
		@%lblTPSpeed = $new(label, @%wgtPageTransferPriority)
		@%lblTPSpeed->$setText(Speed)
		@%lblTPSpeed->$setToolTip("Set the toggle to Speed to give bots with better average transfer speeds priority for automatic downloads")
		
		# slider for speed/success flip flop
		@%slTPSpeedSuccess = $new(slider, @%wgtPageTransferPriority)
		@%slTPSpeedSuccess->$setOrientation(horizontal)
		@%slTPSpeedSuccess->$setMinValue(0)
		@%slTPSpeedSuccess->$setMaxValue(1)
		@%slTPSpeedSuccess->$setLineStep(1)
		
		# label for right side of slider (success)
		@%lblTPSuccess = $new(label, @%wgtPageTransferPriority)
		@%lblTPSuccess->$setText(Success)
		@%lblTPSuccess->$setToolTip("Set the toggle to Success to give bots with better transfer success rates priority for automatic downloads")
		
		# checkbox for channel priority
		@%chbTPToggle = $new(checkbox, @%wgtPageTransferPriority)
		@%chbTPToggle->$setText("Channel")
		@%chbTPToggle->$setToolTip("Toggle channel priority on/off.")
		
		# multilineedit for channel names
		@%mleTPChannels = $new(multilineedit, @%wgtPageTransferPriority)
		@%mleTPChannels->$setTooltip("Enter channel names, one per line, in order of priority. Example:<br/>#charlie<br/>#alpha<br/>#bravo<br/><br/>Gives charlie higher priority than alpha and bravo.")
		@%mleTPChannels->$setWordWrap(NoWrap)
		@%mleTPChannels->$setAlignment(Left)
		@%mleTPChannels->$setFixedSize(@$width,100)
		
		# populate child widgets of Transfer Priority tab
		
		if (%G_hushOptions{"TransferPrioritySpeedSuccess"} != "") { @%slTPSpeedSuccess->$setValue(%G_hushOptions{"TransferPrioritySpeedSuccess"}); }
		else { @%slTPSpeedSuccess->$setValue(0); }
		if (%G_hushOptions{"TransferPriorityToggle"} != "") { @%chbTPToggle->$setChecked(%G_hushOptions{"TransferPriorityToggle"}); }
		else { @%chbTPToggle->$setChecked($true); }
		if ($file.exists(%G_hush->%hushChannelPriority)) 
		{
		#if (%G_hush->%debug) {debug -c loading channel priorites from %G_hush->%hushChannelPriority;}
		@%mleTPChannels->$loadFile(%G_hush->%hushChannelPriority)
		}
		
		# layout for Transfer Priority page
		@%lPageTransferPriority->$addMultiCellWidget(@%lblTPHelp, 0,0,0,2)
		@%lPageTransferPriority->$addMultiCellWidget(@%lblTPSpeed, 1,1,0,0)
		@%lPageTransferPriority->$addMultiCellWidget(@%slTPSpeedSuccess, 1,1,1,1)
		@%lPageTransferPriority->$addMultiCellWidget(@%lblTPSuccess, 1,1,2,2)
		@%lPageTransferPriority->$addMultiCellWidget(@%chbTPToggle, 2,2,0,2)
		@%lPageTransferPriority->$addMultiCellWidget(@%mleTPChannels, 3,3,0,2)
		
		### Searching Tab ###
		@%wgtPageSearching = $new(widget, 0, "options Instant Search Widget for tab")
		@%lPageIS = $new(layout, @%wgtPageSearching)
		
		# searching tab child widgets
		# main on/off switch
		@%chbISToggle = $new(checkbox, @%wgtPageSearching)
		@%chbISToggle->$setText("Enable Hush Database (required for Hush to work)")
		@%chbISToggle->$setToolTip("Toggles the entire Hush database system.<br/>If toggled off nothing will be written to the local database.<br/><b>Hush requires this to be turned on to store and update available content.</b> If you experience performance issues from KVIrc you can turn Hush off by toggling this to see if Hush is the cause of your problems.")
		# passive search on/off switch
		@%chbISPSToggle = $new(checkbox, @%wgtPageSearching)
		@%chbISPSToggle->$setText("Enable Passive Searching (required for auto-downloading)")
		@%chbISPSToggle->$setToolTip("Toggles passive searching.<br/>While on Hush will scan periodically for passive search items.<br/>If you want automatic downloading you need to have this turned on.")
		# obey search exceptions toggle
		@%chbISObeySE = $new(checkbox, @%wgtPageSearching)
		@%chbISObeySE->$setText("Instant Search should obey Search Exceptions")
		@%chbISObeySE->$setToolTip("Toggles whether Instant Search obeys your search exceptions.<br/>Passive searching always obeys your search exceptions. You can get an unfilitered search result in Instant Search if you turn this off.")
		# automate movie title/searches acquisition toggle
		@%chbSearchImportsAutoToggle = $new(checkbox, @%wgtPageSearching)
		@%chbSearchImportsAutoToggle->$setText("Automatically search for popular movies")
		@%chbSearchImportsAutoToggle->$setTooltip("Toggles automated acquisition of popular movie titles.<br/>This will automatically populate the Searches list with upcoming movie titles on a periodic basis.")
		# imported search titles should check the permanent record and obey it
		@%chbSearchImportsObeyPermRecord = $new(checkbox, @%wgtPageSearching)
		@%chbSearchImportsObeyPermRecord->$setText("Don't search for stuff I've had before")
		@%chbSearchImportsObeyPermRecord->$setToolTip("Toggles whether the Searches Import feature will compare new titles against the Permanent Record.<br/><br/>The Permanent Record holds the title names of all movies you have had on your disk drive since using Hush.<br/><br/>If you tick this option, even if you delete a movie file from disk drive, Hush will not add it as a passive search entry through its Searches Import feature.<br/><br/>The idea of this option is so you can delete watched Movies to free up disk space and not have them redownloaded by the automated systems of Hush.")
		# max buffer time widgets
		@%lblISMaxTime = $new(label, @%wgtPageSearching)
		@%lblISMaxTime->$setText("Database Buffer: ")
		@%lblISMaxTime->$setToolTip("Hush database will retain pack announcement data this far back in time.<br/>The bigger this value, the more disk space the database will consume.<br/>Recommended value: 60 minutes")
		@%sbISMaxTime = $new(spinbox, @%wgtPageSearching)
		@%sbISMaxTime->$setMinValue(5)
		@%sbISMaxTime->$setMaxValue(1440)
		@%sbISMaxTime->$setValue(60)
		@%sbISMaxTime->$setSuffix(" minutes")
		@%sbISMaxTime->$setLineStep(10)
		# write buffer size
		@%lblISWriteSize = $new(label, @%wgtPageSearching)
		@%lblISWriteSize->$setText("Write Buffer: ")
		@%lblISWriteSize->$setToolTip("Hush will write announce data to the database after this many announces are caught.<br/>The bigger this value, the longer it takes for announces to be searchable and disk writing will be less frequent.<br/>If you are watching many channels, increase this. If watching few channels, decrease this.<br/>Recommended values<ul><li>1-2 channels: 100</li><li>3-4 channels: 250</li><li>5+ channels: 500")
		@%sbISWriteSize = $new(spinbox)
		@%sbISWriteSize->$setMinValue(50)
		@%sbISWriteSize->$setMaxValue(10000)
		@%sbISWriteSize->$setValue(1024)
		@%sbISWriteSize->$setSuffix(" entries")
		@%sbISWriteSize->$setLineStep(100)
		# passive search frequency
		@%lblISPSFreq = $new(label, @%wgtPageSearching)
		@%lblISPSFreq->$setText("Passive Search Frequency: ")
		@%lblISPSFreq->$setToolTip("Hush will scan for passive searches this often.<br/>The smaller this value, the more CPU power Hush will use but you will find new releases quicker.<br/>Recommended value: 60 minutes")
		@%sbISPSFreq = $new(spinbox, @%wgtPageSearching)
		@%sbISPSFreq->$setMinValue(1)
		@%sbISPSFreq->$setMaxValue(9999)
		@%sbISPSFreq->$setValue(60)
		@%sbISPSFreq->$setSuffix(" minutes")
		@%sbISPSFreq->$setLineStep(5)
		# manual passive search button
		@%btnISPSNow = $new(button, @%wgtPageSearching)
		@%btnISPSNow->$setText(Passive Search Now)
		@%btnISPSNow->$setToolTip("Triggers a passive search to run manually when you click the button.")
		# reset database button
		@%btnISReset = $new(button, @%wgtPageSearching)
		@%btnISReset->$setText(Reset Entire Database)
		@%btnISReset->$setToolTip("Deletes the entire Hush database and reinstates it.")
		
		# populate child widgets of Searching tab
		
		if (%G_hushOptions{"ISEnabled"} != "") {@%chbISToggle->$setChecked(%G_hushOptions{"ISEnabled"});}
		else {@%chbISEnabled->$setChecked($true);}
		if (%G_hushOptions{"ISPSToggle"} != "") {@%chbISPSToggle->$setChecked(%G_hushOptions{"ISPSToggle"});}
		else {@%chbISPSToggle->$setChecked($true);}
		if (%G_hushOptions{"ISObeySE"} != "") {@%chbISObeySE->$setChecked(%G_hushOptions{"ISObeySE"});}
		else {@%chbISObeySE->$setChecked($false);}
		if (%G_hushOptions{"SearchImportsAutoToggle"} != "") {@%chbSearchImportsAutoToggle->$setChecked(%G_hushOptions{"SearchImportsAutoToggle"});}
		else {@%chbSearchImportsAutoToggle->$setChecked($true);}
		if (%G_hushOptions{"SearchImportsObeyPermRecord"} != "") {@%chbSearchImportsObeyPermRecord->$setChecked(%G_hushOptions{"SearchImportsObeyPermRecord"});}
		else {@%chbSearchImportsObeyPermRecord->$setChecked($true);}
		if (%G_hushOptions{"ISMaxTime"} != "") {@%sbISMaxTime->$setValue(%G_hushOptions{"ISMaxTime"});}
		else {@%sbISMaxTime->$setValue(60);}
		if (%G_hushOptions{"ISPSFreq"} != "") {@%sbISPSFreq->$setValue(%G_hushOptions{"ISPSFreq"});}
		else {@%sbISPSFreq->$setValue(60);}
		if (%G_hushOptions{"ISWriteSize"} != "") {@%sbISWriteSize->$setValue(%G_hushOptions{"ISWriteSize"});}
		else {@%sbISWriteSize->$setValue(500);}
		
		# layout for Tab: Searching
		@%lPageIS->$addMultiCellWidget(@%chbISToggle, 0,0,0,1)
		@%lPageIS->$addMultiCellWidget(@%chbISPSToggle, 1,1,0,1)
		@%lPageIS->$addMultiCellWidget(@%chbISObeySE, 2,2,0,1)
		@%lPageIS->$addMultiCellWidget(@%chbSearchImportsAutoToggle, 3,3,0,1)
		@%lPageIS->$addMultiCellWidget(@%chbSearchImportsObeyPermRecord, 4,4,0,1)
		@%lPageIS->$addMultiCellWidget(@%lblISMaxTime, 5,5,0,0)
		@%lPageIS->$addMultiCellWidget(@%sbISMaxTime, 5,5,1,1)
		@%lPageIS->$addMultiCellWidget(@%lblISWriteSize, 6,6,0,0)
		@%lPageIS->$addMultiCellWidget(@%sbISWriteSize, 6,6,1,1)
		@%lPageIS->$addMultiCellWidget(@%lblISPSFreq, 7,7,0,0)
		@%lPageIS->$addMultiCellWidget(@%sbISPSFreq, 7,7,1,1)
		@%lPageIS->$addMultiCellWidget(@%btnISPSNow, 8,8,0,1)
		@%lPageIS->$addMultiCellWidget(@%btnISReset, 9,9,0,1)
		
		### Media Centre Tab ###
		@%wgtPageMediaCentre = $new(widget, , "options Media Centre Widget for tab")
		@%lPageMC = $new(layout, @%wgtPageMediaCentre)
		
		# media centre tab child widgets
		# label info message
		@%lblMediaCentreInfo = $new(label, @%wgtPageMediaCentre)
		@%lblMediaCentreInfo->$setText("<table border=0><tr><td colspan=2><b>Media Centre Support</b><br/>Configure to notify media centre or server machines here. <i>Kodi devices up to the Krypton version and Plex servers are supported.</i> You can add multiple devices to the edit box below, one line per device. Only the device type and IP address is mandatory, blank lines are ignored and this updates the Video library for Kodi only. Plex server will refresh the entire library. The format for a line is: <br/><br/>&lt;type|&gt;[user:pass@]&lt;IP Address&gt;[:port][|Plex Token]<br/></td></tr><tr><td width=50%><b>Examples:</b> <br/>kodi|kodi:kodi@192.168.0.50:8080<br/>kodi|192.168.0.50:80<br/>kodi|192.168.0.50<br/>plex|192.168.0.110:32400|3fjn9863cvj89232d</td><td width=50%><b>Media Device Types</b><ul><li>kodi</li><li>plex - Plex devices require a PlexToken to perform remote library updates. The default port for Plex is 32400.</li></ul></td></tr></table>")
		@%lblMediaCentreInfo->$setAlignment(Top)
		# label for media centre devices multilineedit
		@%lblMediaCentreDevices = $new(label, @%wgtPageMediaCentre)
		@%lblMediaCentreDevices->$setText("<hr/><b>Media Centre Devices</b>")
		@%lblMediaCentreDevices->$setAlignment(Top)
		# multilineedit for media centre devices
		@%mleMediaCentreDevices = $new(multilineedit, @%wgtPageMediaCentre)
		@%mleMediaCentreDevices->$setTooltip("Enter media centre device info in here as outlined above.")
		@%mleMediaCentreDevices->$setWordWrap(NoWrap)
		@%mleMediaCentreDevices->$setAlignment(Left)
		@%mleMediaCentreDevices->$setFixedSize(@$width,100)
		# button to manually update media centre devices
		@%btnMediaCentreUpdate = $new(button, @%wgtPageMediaCentre)
		@%btnMediaCentreUpdate->$setText("Update Devices Now")
		@%btnMediaCentreUpdate->$setTooltip("Click this to send update commands to your media centres now")
		
		
		# populate widgets
		if ($file.exists(%G_hush->%hushMediaCentres)) 
		{
		#if (%G_hush->%debug) {debug -c loading external media centre details from %G_hush->%hushMediaCentres;}
		@%mleMediaCentreDevices->$loadFile(%G_hush->%hushMediaCentres)
		}
		
		# layout for Tab: Media Centre
		@%lPageMC->$addMultiCellWidget(@%lblMediaCentreInfo, 0,0,0,1)
		@%lPageMC->$addMultiCellWidget(@%lblMediaCentreDevices, 1,1,0,1)
		@%lPageMC->$addMultiCellWidget(@%mleMediaCentreDevices, 2,2,0,1)
		@%lPageMC->$addMultiCellWidget(@%btnMediaCentreUpdate, 3,3,0,1)
		
		# add pages to tab
		@%tabw->$addTab(@%wgtPageBasic, "&Basic")
		@%tabw->$addTab(@%wgtPageSearching, "&Searching")
		@%tabw->$addTab(@%wgtPageTransfers, "&Transfers")
		@%tabw->$addTab(@%wgtPageTransferPriority, "Transfer &Priority")
		@%tabw->$addTab(@%wgtPageMediaCentre, "&Media Centre")
		
		# base tab
		
		@%l0->$addMultiCellWidget(@%lblTitle, 0,0,0,0)
		@%l0->$addMultiCellWidget(@%tabw, 1,1,0,0);
		
		objects.connect @%btnISPSNow clicked %G_hush doPassiveSearch
		objects.connect @%btnISReset clicked $$ fnISReset
		objects.connect @%sbTransfersDCCTimeout valueChanged $$ slotTransfersDCCTimeoutChange
		objects.connect @%btnMediaCentreUpdate clicked %G_hush updateMediaCentres
		
		### private impls
		
		privateimpl(@%chbISToggle, toggleEvent)
		{
			if (@$isChecked)
				%G_hush->%leIS->$show()
			else
				%G_hush->%leIS->$hide()
		}
		
		privateimpl($$, keyPressEvent)
		{
			if ($0 == "4")
			{
				%G_hush->%dbgI++
				if (%G_hush->%dbgI == 4)
				{
					%G_hush->%debug = $(!%G_hush->%debug)
					%G_hush->%dbgI = 0
					%dbgMsg = "Debug mode is now "
					if (%G_hush->%debug == $false) {%dbgMsg = $str.append(%dbgMsg, "off");}
					else {%dbgMsg = $str.append(%dbgMsg, "on");}
					debug -c %dbgMsg
					%G_hush->$showMain
					@$raise
					@$setFocus
				}
			}
		}
		
		privateimpl($$, closeEvent)
		{
			# closing the settings::options window so we need to set and save all the values
			%G_hushOptions{"FCW"} = @%leFCW->$text()
			%G_hushOptions{"ISEnabled"} = @%chbISToggle->$isChecked()
			%G_hushOptions{"ISMaxTime"} = @%sbISMaxTime->$value()
			%G_hushOptions{"ISObeySE"} = @%chbISObeySE->$isChecked()
			%G_hushOptions{"ISPSToggle"} = @%chbISPSToggle->$isChecked()
			%G_hushOptions{"ISPSFreq"} = @%sbISPSFreq->$value()
			%G_hushOptions{"ISWriteSize"} = @%sbISWriteSize->$value()
			%G_hushOptions{"NoiseNone"} = @%cbNoiseNone->$isChecked()
			%G_hushOptions{"SearchImportsAutoToggle"} = @%chbSearchImportsAutoToggle->$isChecked()
			%G_hushOptions{"SearchImportsObeyPermRecord"} = @%chbSearchImportsObeyPermRecord->$isChecked()
			%G_hushOptions{"SWC"} = @%cbSWC->$isChecked()
			%G_hushOptions{"SSL"} = @%cbSSL->$isChecked()
			%G_hushOptions{"TransfersAutoEpUp"} = @%chbTransfersAutoEpUp->$isChecked()
			%G_hushOptions{"TransfersAutoExtract"} = @%chbTransfersAutoExtract->$isChecked()
			%G_hushOptions{"TransfersAutoMCUpdate"} = @%chbTransfersAutoMCUpdate->$isChecked()
			%G_hushOptions{"TransfersAutoMove"} = @%chbTransfersAutoMove->$isChecked()
			%G_hushOptions{"TransfersAutoStopPassive"} = @%chbTransfersAutoStopPassiveToggle->$isChecked()
			%G_hushOptions{"TransfersAutoStopWrongFile"} = @%chbTransfersAutoStopWrongFileToggle->$isChecked()
			%G_hushOptions{"TransfersAutoToggle"} = @%chbTransfersAutoToggle->$isChecked()
			%G_hushOptions{"TransfersDoneMsg"} = @%chbTransfersDoneMsg->$isChecked()
			%G_hushOptions{"TransfersMaxRetries"} = @%sbTransfersMaxRetries->$value()
			%G_hushOptions{"TransfersMaxTransfers"} = @%sbTransfersMaxTransfers->$value()
			%G_hushOptions{"TransferPrioritySpeedSuccess"} = @%slTPSpeedSuccess->$value()
			%G_hushOptions{"TransferPriorityToggle"} = @%chbTPToggle->$isChecked()
			%G_hushOptions{"TransfersRetryToggle"} = @%chbTransfersRetryToggle->$isChecked()
			%G_hushOptions{"TransfersRmSearchTerm"} = @%chbTransfersRmSearchTerm->$isChecked()
			%G_hushOptions{"TransfersSSLAuto"} = @%chbTransfersSSLAuto->$isChecked()
			%G_hushOptions{"ZNCPush"} = @%cbZNCPush->$isChecked()
			%G_hushOptions{"ZNCPreventQuery"} = @%cbZNCPreventQuery->$isChecked()
		#	if (%G_hush->%debug) {debug -c saving external media centre details to %G_hush->%hushMediaCentres;}
			@%mleMediaCentreDevices->$saveFile(%G_hush->%hushMediaCentres)
		#	if (%G_hush->%debug) {debug -c saving channel priorities to %G_hush->%hushMediaCentres;}
			@%mleTPChannels->$saveFile(%G_hush->%hushChannelPriority)
		
			# loadFile is called to enact changes on close of the options widget
			@%mleTPChannels->$loadFile(%G_hush->%hushChannelPriority)
			@%mleMediaCentreDevices->$loadFile(%G_hush->%hushMediaCentres)
		}
		
		privateimpl(@%btnCHS, mousePressEvent)
		{
			# clicked clear haystack button
			%G_hush->%options->$clearHaystack()
		}
		
		privateimpl(@%btnESTF, mousePressEvent)
		{
			# clicked export setting to file button
			# get filename to export to from user and save in $fileIO function
			%G_hush->%options->$fileIO("save", "Select path and filename to export settings", "hushSettings.txt", "All files (*.*)", "hushESTF")
		}
		
		privateimpl(@%btnISFF, mousePressEvent)
		{
			# clicked import setting from file button
			# get filename to import from from user and load in $fileIO function
			%G_hush->%options->$fileIO("open", "Select path and filename to import settings", "hushSettings.txt", "All files (*.*)", "hushISFF")
		}
		
		privateimpl(@%chbISObeySE, toggleEvent)
		{
			# alter the status bar value on the instant search window
			if (@$isChecked) { %G_hush->%instantSearch->%lblISSEStatus->$setText("Search Exceptions are being obeyed"); }
			else {%G_hush->%instantSearch->%lblISSEStatus->$clear();}
			%G_hushOptions{"ISObeySE"} = @$isChecked()
		}
		
		privateimpl(@%chbISPSToggle, toggleEvent)
		{
			# set the hush database harvesting to stop
			%G_hushOptions{"ISPSToggle"} = @$isChecked()
			if (!@$isChecked())
			{
				killtimer -q hushPassiveSearch
				if (%G_hush->%debug) {debug -c $k(4)Disabled Timer$k() 'hushPassiveSearch'. Passive searching will not work with this option turned off.;}
			}
			else
			{
				%G_hush->$timerPassiveSearch()
			}
		}
		
		privateimpl(@%chbSearchImportsAutoToggle, toggleEvent)
		{
			# toggle automated movie title acquisition
			%G_hushOptions{"SearchImportsAutoToggle"} = @$isChecked()
			if (!@$isChecked())
			{
				%G_hush->%searchImportsAutoFlag = $false
				killtimer -q hushSearchImportsAutoAcquisition
				if (%G_hush->%debug) {debug -c $k(4)Disabled Timer$k() 'hushSearchImportsAutoAcquisition';}
			}
			else
			{
				%G_hush->%searchImportsAutoFlag = $true
				%G_hush->$timerSearchImportsAutoAcquisition()
			}
		}
		
		privateimpl(@%sbISPSFreq, valueChangedEvent)
		{
			# change of the passive search timer, so kill and reset the timer
			killtimer -q hushPassiveSearch
			%G_hushOptions{"ISPSFreq"} = @$value()	
		#	if (%G_hush->%debug) {debug -c Passive search timer value changed to shoot every @$value minutes.;}
			if (%G_hushOptions{"ISPSToggle"})
			{
				%G_hush->$timerPassiveSearch()
				if (%G_hush->%debug) {debug -c Resetting hushPassiveTimer.;}
			}
		}
		
		privateimpl(@%chbTransfersSSLAuto, toggleEvent)
		{
			# alter the send type for all auto-downloads in the downloadHash
			if (@$isChecked) {%G_hush->$editDHAutos(sendStyle,SSEND);}
			else {%G_hush->$editDHAutos(sendStyle,SEND);}
			%G_hushOptions{"TransfersSSLAuto"} = @$isChecked()
		}
		
		privateimpl(@%chbTPToggle, toggleEvent)
		{
			# change the value of the Transfer Priority Toggle in G_hushOptions
			%G_hushOptions{"TransferPriorityToggle"} = @$isChecked()
		}
	}
	
	function clearHaystack(function to clear the smart mode haystack array)
	{
		# options function to clear the smart mode haystack
		if (%G_hush->$dbClearTable(haystack))
		{
			dialog.message -b ("Notice", "Passive Search Haystack has been cleared.", information, "OK") {}
		}
		else
		{
			dialog.message -b ("Notice", "Haystack clear was unsuccessful! Check debug messages for details.", information, "OK") {}
		}
	}
	
}

class("hush::main","widget")
{
	function updateValues(updates some values useful to Hush operation)
	{
		# update irc context values - irc context values need to be updated when irc connections are established. see events->onIRCConnectionEstablished
		%context = $context.list()
		%count = 0;
		if (%context)
		{
			for (%i = 0; %i < %context[]#; %i++)
			{
				%contextName = $context.networkName(%context[%i])
				if (%contextName != "") 
				{
					%temp{"%contextName"} = %context[%i];
					%count++;
				}
			}
			@%ircContexts = %temp
		#	if (@%debug) {debug -c Updating IRC context values. %count IRC contexts found.;}
		}
		else
		{
			debug -c Could not retrieve context values from function context.list;
		}
	}
	
	function updateMediaCentres(this function updates external media centre devices on your network so they scan for new content and add it to their library)
	{
		/* please note that this function is solely for updating external media player device and is nothing to do with 
		 Hush's "media library".
		
		stuff related to this function: 
		
		@%hushMediaCentres is the path to the mediaCentres config file
		
		%G_hush->%options->%mleMediaCentreDevices is the widget that holds the details for media centres to be updated
		  $loadFile(path) $savefile(path)
		  <integer> $lines() - returns number of lines in mle
		  <integer> $numLines() - returns number of lines too but it's different! wouldn't work with this function.
		  <string> $text() - returns all text in mle
		  <string> $textLine(<line:integer>) - returns text at line number (return value can be empty)
		*/
		
		
		# simple test, loop through lines in %G_hush->%options->%mleMediaCentreDevices and output to debug
		%lines = %G_hush->%options->%mleMediaCentreDevices->$lines()
		if (%G_hush->%debug) {debug -c lines found in MC mle: %lines;}
		for (%i = 0; %i < %lines; %i++)
		{
			%line = %G_hush->%options->%mleMediaCentreDevices->$textLine(%i)
			if (!$isEmpty(%line)) 
			{
				if (%G_hush->%debug) {debug -c %i\: %line;}
				%ftWinBefore = $window("File Transfers")
				%mcInfo[] = $str.split(|,%line)
				if (%mcInfo[]# >= 2)
				{
					# set the updateCommand according to the media device type from %line
					%updateCommand = $false
					switch (%mcInfo[0])
					{
						case(kodi):
							%updateCommand = http://%mcInfo[1]/jsonrpc?request=\{\"jsonrpc\":\"2.0\",\"method\":\"VideoLibrary.Scan\"\}
							break;
						case(plex):
							if (%mcInfo[2])
							{
								%updateCommand = http://%mcInfo[1]/library/sections/all/refresh?X-Plex-Token=%mcInfo[2]
								if (%G_hush->%debug) {debug -c Device type is 'plex'. Token found was: %mcInfo[2]\nURL will be: %updateCommand;}
							}
							else
							{
								if (%G_hush->%debug) {debug -c $k(7)Did not find a Plex Token value from the settings!$k() Plex library updates won't work without one!;}
							}
							break;
						default:
							if (%G_hush->%debug) {debug -c The first item in mcInfo was not a known device type! mcInfo[0] = %mcInfo[0]\nCheck/change this value in Options -> Media Center and try again;}
							break;
					}
					if (%updateCommand)
					{
						# run http.get (needs async callback)
						http.asyncGet --winctrl=h --no-output --clear --quiet --identifier=%mcInfo[0]|%mcInfo[1] --timeout=8 (%updateCommand, $file.localdir("Hush/config/mcUpdate-%mcStr.html"), %mcInfo[1])
						{
							if (%G_hush->%debug) {debug -c updateMediaCentres: this callback is for device: $3;}
							if ($file.exists($file.localdir("Hush/config/mcUpdate-$3\.html")))
							{
								if ($file.size($file.localdir("Hush/config/mcUpdate-$3\.html") == 0))
								{
									if (%G_hush->%debug) {debug -c updateMediaCentres: update seemed to be a success;}
								}
								else
								{
									if (%G_hush->%debug) {debug -c updateMediaCentres: update probably failed. filesize of response file was != 0;}
								}
							}
							else
							{
								if (%G_hush->%debug) {debug -c updateMediaCentres: update might have been a success? response file didn't exist but that might be because the http.asyncGet function removed it already?;}
							}
							# remove file that http.get creates (can check size of file to see if success. 0 filezie = OK)
						}
						if (%G_hush->%debug) {debug -c $k(9)sent the update request for $k()%mcInfo[0] $k(9)device at$k() %mcInfo[1];}
					}
					else
					{
						if (%G_hush->%debug) {debug -c Could not update this media center entry because $k(7)the update command was not able to be built$k().;}
					}
				}
				else
				{
					if (%G_hush->%debug) {debug -c Could not update this media center entry because $k(7)mcInfo array did not contain 2 items.$k() length(mcInfo) = $length(%mcInfo)\nFirst 3 items in mcInfo array:\n0: %mcInfo[0]\n1: %mcInfo[1]\n2: %mcInfo[2];}
				}
				%ftWinAfter = $window("File Transfers")
				if (%G_hushOptions{"MediaCentreFTWClose"} && %ftWinBefore == 0 && %ftWinAfter > 0)
				{
					if (%G_hush->%debug) {debug -c file transfer window was not open before we requested this MC update so we will close it;}
					window.close -q %ftWinAfter
				}
			}
		}
	}
	
	function uninstall(Uninstalls all of Hush)
	{
		echo "Attempting to uninstall..."
		echo "Action: hushMain"
		action.destroy hushMain
		echo "Alias: (namespace) xdcc"
		alias (xdcc::) {}
		echo "Event: onChannelMessage->hilights"
		event (onChannelMessage, hilights) {}
		echo "Class: (namespace) hush"
		objects.killclass "hush::about"
		objects.killclass "hush::changelog"
		objects.killclass "hush::channels"
		objects.killclass "hush::help"
		objects.killclass "hush::main"
		objects.killclass "hush::options"
		objects.killclass "hush::searches"
		echo "Toolbar: hushMain"
		toolbar.destroy hushMain
		echo "Uninstall finished."
	}
	
	function timerSearchImportsAutoAcquisition(timer that automatically acquires movie titles for the searches list)
	{
		/* this function creates a timer that will trigger automated movie title acquisition
		
		the callback code for this timer will call the G_hush->searches->import->$fetchResults function which has a callback block of
		its own. Because fetchResults has a callback, this function's callback will set a flag value which will tell the fetchResults
		callback to call G_hush->searches->import->$addToSearches
		
		So the flow of the automated movie title acquisition timer system is:
		
			G_hush->options->chbSearchImportsAutoToggle (user ticks checkbox in options, this function is called and the timer is created)
			G_hush->timerSearchImportsAutoAcquisition::callback (checks required data, and calls G_hush->searches->import->fetchResults)
				Note: fetchResults is called with the 3rd parameter set to $true which tells it to 
			G_hush->searches->import->fetchResults (runs and creates a http.async download, which has a callback when the file finishes downloading)
			http.asyncGet::callback (found in searchesimport->fetchResults, parses the downloaded page and builds a list of movie titles)
				http.asyncGet::callback see the automated flag is true and calls G_hush->searches->import->$addToSearches immediately
			G_hush->searches->import->addToSearches adds all valid title names to the Searches list and toggles the automated flag to false if it is set to true.
		
		Why all this automated flag business? Because we are using the same functions that get called when the user manually imports titles.
		If we don't have an automated flag value, if we do a manual title import the functions will just go adding titles without the user 
		telling it to do it.
		
		Also this is here for in the future when you forget how all the flow of this works!
			
		*/
		
		
		# interval: 60000 = 1 minute
		%interval = $(60000 * 60 * 24)
		# ^^^ this is set to once every 1 day
		
		timer (hushSearchImportsAutoAcquisition, %interval)
		{
			%debugMsg = "DEBUG timer callback: $k(12)hushSearchImportsAutoAcquisition$k()";
			%debugMsg .= "hushSearchImportsAutoAcquisition: Timer shot triggered."
			if ($isSet(%G_hush->%searchesImport))
			{
				if (%G_hush->%searchesImport->$className() == "hush::searchesimport")
				{
					if (%G_hush->%searchImportsAutoFlag == $false) {%G_hush->%searchImportsAutoFlag = $true;}
					# hard coded to use imdb calendar for the automated movie title acquisition
					%G_hush->%searchesImport->$fetchResults("https://imdb.com/calendar","IMDB Calendar")
				}
				else
				{
					%debugMsg .= "\nError: G_hush->searchesImport object is not class type 'hush::searchesimport'. Check data and try again."
				}
			}
			else
			{
				%debugMsg .= "\nError: G_hush->searchesImport object is not set. Check data and try again."
			}
			%debugMsg .= "\nhushSearchImportsAutoAcquisition: Timer callback ended"
		}
		
		if (%G_hush->%debug) {debug -c timer 'hushSearchImportsAutoAcquisition' activated to fire on interval of %interval milliseconds\nUse: /listtimers to see timer info;}
	}
	
	function timerPassiveSearch(timer code that periodically searches the hush database for passive searches)
	{
		timer (hushPassiveSearch, $(%G_hushOptions{"ISPSFreq"} * 60000))
		{
			if (%G_hush->%debug) {debug -c hushPassiveTimer: Timer shot triggered. (This is a persistent timer);}
			%G_hush->$doPassiveSearch($true);
			if (%G_hush->%debug) {debug -c hushPassiveTimer: Timer callback ended;}
		}
		
		if (%G_hush->%debug) {debug -c timer 'hushPassiveSearch' activated to fire on interval of %G_hushOptions{"ISPSFreq"} minutes\nUse: /listtimers to see timer info;}
	}
	
	function timerDCCStats()
	{
		# this function creates the timer that will check the stats on all active dcc transfers and will
		# update the xdccobject stats
		
		timer (hushCheckDCCs, 10000)
		{
			# check that our xdccobject array exists
			if ((%G_hushXdccObs[]# <= 0) || (%G_hushXdccObs == $false))
			{
				# object array doesn't exist. kill timer and halt code
				killtimer 
				halt 
			}
			else
			{
				# xdccobject array exists, loop it and find any xdccobjects that are currently active
				for (%i = 0; %i < %G_hushXdccObs[]#; %i++)
				{
					if ((%G_hushXdccObs[%i]->$getInfo(status) == Receiving) && $dcc.transferStatus(%G_hushXdccObs[%i]->$getInfo(sessionID)) == transferring)
					{
						
					}
				}
			}
		}
	}
	
	function sortDHByPriority(sorts the hush downloadHash  so that the packs are ordered by best to worst priority for the botNames)
	{
		/* this function will sort the hush DownloadHash by botName priority
		
			Parameters:
			$0 - priorityArray (array)	- the priority array returned from hush::botStats[getPriority]
		
			returns true on success else false
		*/
		
		%dlh = %G_hushDownloadhash
		%priorityArray = $0
		%success = $false
		
		if ($typeOf(%priorityArray == array))
		{
			%tempArray = $array
			%tempHash = $hash
		
			# check which searchTerm arrays have Queued items in the downloadHash
			%stCheck = %G_hush->$searchDownloadHashForStatus(Queued, %dlh);
			
			# remove duplicates from stCheck
			foreach (%stRef, %stCheck)
			{
				# split the searchTerm reference
				%st = $str.section(%stRef,|||,0,0)
				if ($str.grep(%st, %tempArray) == $false)
				{
					%tempArray <+ %st
				}
			}
			%stCheck = %tempArray
		
			# reset tempArray
			%tempArray = $null
		
			# loop the stCheck array
			foreach (%searchTerm, %stCheck)
			{
				# dev-note: %searchTerm holds a search term string like: *supergirl*s05e01*
				%leftovers = $null
				# loop priorityArray to get botNames in order of priority
				foreach (%botName, %priorityArray)
				{
					# dev-note: %botName contains a botname. Each time this loops, we get the next botname from the priority list. Starts from highest priority and moves to lowest priority
					# loop dlh
					for (%i = 0; %i < %dlh{%searchTerm}[]#; %i++)
					{
						# gets an xdccobject from a relevant {searchTerm} in the dlh
		 				%xdccObject = %dlh{%searchTerm}[%i]
						# check what we have is actually an object
						if ($typeOf(%xdccObject) == hobject)
						{
							# check the botname of the current xdccobject against the current name from the priority list
							if (%xdccObject->$getInfo(botName) == %botName)
							{
								# add current xdccobject to a temporary hash if it matches the priority list botname
								%tempHash{%searchTerm} <+ %xdccObject;
								# set this xdccobject in the dlh to null so we don't process it again.
								%dlh{%searchterm}[%i] = $null
							}
						}
					}
				}
			}
		
			# loop the remaining xdccobjects in the dlh and send its contents to the tempHash
			# note: the remaining xdccobject will be any packs offered by bots that don't exist yet in the botstats table.
		
			# dev-note: realize that here, we have to do 2 loops because we need the searchTerm value. 
			#		 if we do: foreach (%searchTerm, %dlh) then %searchTerm would be an xdccobject, not a string (the hash key)
		
			foreach (%searchTerm, $keys(%dlh))
			{
				foreach (%xdccObject, %dlh{%searchTerm})
				{
					if ($typeOf(%xdccObject == object)) {%tempHash{%searchTerm} <+ %xdccObject;}
				}
			}
		
			# at this point, %tempHash holds the sorted-by-priority results for the downloadHash.
			# copy the tempHash to the G_hushDownloadHash
		
			%G_hushDownloadHash = %tempHash;
			%success = %G_hushDownloadHash;
		}
		else
		{
			if (@%debug) {debug -c First argument passed $k(4)(priorityArray) was not type array$k(). type was: $typeOf(%priorityArray);}
		}
		
		return %success
	}
	
	function showTransferStats()
	{
		# this function will add active transfer stats to the main hush widget when there is an active transfer
		
		/* widgets to build:
			label: "Active Transfers"
			label: "Current Transfers integer"
			label: "Current Total Speed float MB/sec"
			progressbar: "Total Progress % done of all current transfers"
		*/
		
		@%lblATrans = $new(label, $$)
		@%lblATrans->$setText(Active Transfers: #ACTIVE_TRANS#)
		
		@%lblCurTrans = $new(label, $$)
		@%lblCurTrans->$setText(Current Transfers: #CURRENT_TRANS#)
		
		@%lblCurTotSpeed = $new(label, $$)
		@%lblCurTotSpeed->$setText(Current Total Speed: #CURRENT_TOTAL_SPEED# MiB/sec)
		
		@%lblProgressBar = $new(label, $$)
		@%lblProgressBar->$setText(Current Progress)
		
		@%pbTotProgress = $new(progressbar, $$)
		@%pbTotalProgress->$setPercentageVisible($true)
		@%pbTotalProgress->$setTotalSteps(100)
	}
	
	function showSearchesImport(displays the Searches::Import widget on the screen)
	{
		# dev-note: searches->import requires a searches object to exist.
		
		# debug -c we are trying to show the searches import widget
		
		if ($objects.exists(@%searches) == $false)
			@%searches = $new(hush::searches)
		
		if ($objects.exists(@%searchesImport) == $false)
			@%searchesImport = $new(hush::searchesimport)
		
		@%searchesImport->$show()
		@%searchesImport->$raise()
		@%searchesImport->$setFocus()
	}
	
	function showSearches(show settings::Searches widget)
	{
		if ($objects.exists(@%searches) == 0)
			@%searches = $new(hush::searches)
		#debug -c searches object's existence: $objects.exists(@%searches)
		@%searches->$show()
		@%searches->$raise()
		@%searches->$setFocus()
		
		# searches list needs to be populated from %G_hushSearches to @%lbS listbox
		
		# sort searches array
		%G_hushSearches = $sort(%G_hushSearches)
		
		@%searches->%lbS->$clear()
		for (%i = 0; %i < $length(%G_hushSearches); %i++)
		  @%searches->%lbS->$insertItem(%G_hushSearches[%i])
		
		%lblHomeSuffix = " - %G_hushSearches[]# entries"
		%G_hush->%searches->%lblHomeMsg->$setText("<b>Searches</b>"%lblHomeSuffix)
	}
	
	function showQueueEditor(displays the queue editor widget on the screen)
	{
		if ($objects.exists(@%queueeditor) == 0)
		{
			@%queueeditor = $new(hush::queueeditor)
			@%queueeditor->$refreshQueue()
		}
		
		
		@%queueeditor->$show()
		@%queueeditor->$raise()
		@%queueeditor->$setFocus()
	}
	
	function showOptions(show settings::Options widget)
	{
		if ($objects.exists(@%options) == 0)
			@%options = $new(hush::options);
		@%options->$show()
		@%options->$raise()
		@%options->$setFocus()
	}
	
	function showMLibrary()
	{
		# this function should show us a different widget, not the library options widget.
		
		if ($objects.exists(@%libraryoptions) == 0)
			@%libraryoptions = $new(hush::options)
		@%libraryoptions->$show()
	}
	
	function showMain(shows hush::Main widget)
	{
		# update the values for debug values on the main window if debug is on
		%lblHome = "Manage your watched channels, searches, options and media library settings using the buttons below.<br/><br/>Press Ctrl+Alt+I for Instant Search window.<br/><br/><b>Hover the mouse for tooltips.</b><br/><br/>For more information about and help with Hush, see the information section."
		if (@%debug)
		{
			%lblHome .= "<br/><br/>Debug mode is on. Some interesting values: "
			%lblHome .= "<br/>G_hushLive{iTransfersActive} = %G_hushLive{"iTransfersActive"}"
			%lblHome .= "<br/>G_hushHaystack size = %G_hushHaystack[]#"
			%lblHome .= "<br/>G_hushDownloadHash size = $length(%G_hushDownloadHash)"
			%lblHome .= "<br/><a href=\"http://www.google.com/\">Google</a> test"
			@%lblHomeMsg->$setAlignment(Top)
		}
		else
		{
			@%lblHomeMsg->$setAlignment(VCenter)
			%lblHome .= "<br/><br/><b>Current Auto-Downloads:</b> %G_hushLive{"iTransfersActive"} of %G_hushOptions{"TransfersMaxTransfers"}"
		}
		@%lblHomeMsg->$setText(%lblHome)
		
		# if Hush main widget is open, close it down and reopen it
		if (%G_hush->$isVisible)
			@$hide()
		@$show()
		
		@$updateValues()
		if (!$isTimer(hushPassiveSearch) && %G_hushOptions{"ISPSToggle"}) {@$timerPassiveSearch();}
	}
	
	function showLibraryOptions(shows hush::libraryoptions widget)
	{
		# dev-note: libraryoptions requires a hush::library object to exist.
		
		if ($objects.exists(@%library) == 0)
			@%library = $new(hush::library);
		
		if ($objects.exists(@%libraryoptions) == 0)
			@%libraryoptions = $new(hush::libraryoptions)
		@%libraryoptions->$show()
	}
	
	function showInstantSearch(shows Instant Search widget on screen)
	{
		if ($objects.exists(@%instantSearch) == 0)
		{
			@%instantSearch = $new(hush::instantSearch, 0, "Hush Instant Search widget")
			@%instantSearch->%leIS->$setFocus();
		}
		# ensure we have a database connection
		if (@%sql->$className() != sql)
		{
			if (@$dbConnect())
			{
				@%instantSearch->$show();
				@%instantSearch->%leIS->$setFocus();
				halt;
			}
			else
			{
				if (@%debug) debug -c nope! could not connect to sqlite database. this is a fatal error for instant searching purposes
				dialog.message -b ("Error", "Nope! Could not connect to the Instant Search database. This is a fatal error so we can't open the Instant Search window.", critical, "/okay...") {}
				halt;
			}		
		}
		else
		{
			@%instantSearch->$show();
			@%instantSearch->%leIS->$setFocus();
			halt;
		}
	}
	
	function showHelp(shows hush::Help widget)
	{
		help.open $file.localdir("help/Hush/en/hushHelp.html")
	}
	
	function showChannels(shows Settings::Channels widget)
	{
		if ($objects.exists(@%channels) == 0)
			@%channels = $new(hush::channels);
		@%channels->$show()
	}
	
	function showChangelog(shows hush::Changelog widget)
	{
		help.open $file.localdir("help/Hush/en/hushChangelog.html")
	}
	
	function showAbout(shows hush::About widget)
	{
		help.open $file.localdir("help/Hush/en/hushAbout.html")
	}
	
	function searchDownloadHashForStatus($0 - the status to look for)
	{
		/* this function searches the G_hushDownloadHash hash table to find xdccobjects that have a particular status
			Parameters: 
		
				$0 - status
				$1 - [OPTIONAL] - hash to search
					Note: If no hash argument is passed, this function will default to using the Hush downloadHash (ie: %G_hushDownloadHash)
		
			Return value - this function will return an array of strings that are download hash keys: searchTerm|||index
		*/
		
		%return = $array
		%n = 0
		%find = $0
		%targetHash = $1
		
		# set targetHash to hushDownloadHash if a hash was not passed to this function
		if (%targetHash == $false || $typeOf(%targetHash) != hash) {%targetHash = %G_hushDownloadHash;}
		
		# dev-note: realize that you can try to loop an empty hash and KVS will not complain about it.
		foreach (%key, $keys(%targetHash))
		{
		#	debug -c [dev debug] key = %key
			for (%i = 0; %i < $length(%targetHash{"%key"}); %i++)
			{
		#		debug -c [dev debug] botName = %targetHash{%key}[%i]->$getInfo(botName)
				if (%targetHash{"%key"}[%i]->$getInfo(status) == %find)
				{
					%return[%n] = %key|||%i
					%n++
				}
			}
		}
		
		if (%return[]# > 0)
		{
			return %return 
		}
		else
		{
			return $false;
		}
	}
	
	function searchDownloadHashForID(this function searches the download has specifically for botname, status and sessionID. it is used by events::onDCCFileTransferBegin when the filename sent doesnt match what we expected)
	{
		# this function searches the G_hushDownloadHash hash table to find an xdcc object that matches a DCC transfer
		# $0 - botName
		# $1 - sessionID
		# $2 - status
		
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			for (%i = 0; %i < $length(%G_hushDownloadHash{"%key"}); %i++)
			{
				if (%G_hushDownloadHash{%key}[%i]->$getInfo(botName) == $0)
				{
					if (@%debug) {debug -c this entry matches the botname: $0;}
					if (%G_hushDownloadHash{%key}[%i]->$getInfo(sessionID) == $1)
					{
						if (@%debug) {debug -c this entry matches the sessionID: $1;}
						if (%G_hushDownloadHash{%key}[%i]->$getInfo(status) == $2)
						{
							if (@%debug) {debug -c this entry matches the status: $2;}
							return %key|||%i;
						}
						else
						{
							if (@%debug) {debug -c the status does not match: $2 vs %G_hushDownloadHash{%key}[%i]->$getInfo(status);}
						}
					}
					else
					{
						if (@%debug) {debug -c the sessionID does not match: $1 vs %G_hushDownloadHash{%key}[%i]->$getInfo(sessionID);}
					}
				}
			}
		}
		return $false
	}
	
	function searchDownloadHashForBot(searches the download hash by botname and status only)
	{
		# this function searches the G_hushDownloadHash hash table to find an xdcc object that matches a botName and Status
		# this function is used by the onQueryNotice event handler to identify which xdccobject may be failing
		# $0 - botName
		# $1 - status
		
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			for (%i = 0; %i < $length(%G_hushDownloadHash{"%key"}); %i++)
			{
				if (%G_hushDownloadHash{%key}[%i]->$getInfo(botName) == $0)
				{
					if (@%debug) {debug -c this entry matches the botname: $0;}
					if (%G_hushDownloadHash{%key}[%i]->$getInfo(status) == $1)
					{
						if (@%debug) {debug -c this entry matches the status: $1;}
						return %key|||%i;
					}
					else
					{
						if (@%debug) {debug -c "%key|||%i matches bot: $0\ndoes not match status: $1 $k(14)vs$k() %G_hushDownloadHash{%key}[%i]->$getInfo(status)";}
					}
				}
			}
		}
		return $false
	}
	
	function searchDownloadHash(searches G_hushDownloadHash to find the best match of a DCC transfer. returns false if no match is found)
	{
		# this function searches the G_hushDownloadHash hash table to find an xdcc object that matches a DCC transfer
		# $0 - botName
		# $1 - packName
		
		%statusStop = "Cancelled, Cancelled (Invalid Pack Number), Cancelled (Unsupported Command), Cancelled (Bot Not Sending), Cancelled (Bot Removed Us), Complete, Connecting, Failed, Receiving, Retrying, User Aborted, User Cancelled"
		%statusContinue = "Never Started, Requested, Waiting (RQ)"
		
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			for (%i = 0; %i < $length(%G_hushDownloadHash{%key}); %i++)
			{
				if (%G_hushDownloadHash{%key}[%i]->$getInfo(botName) == $0)
				{
					if (%G_hushDownloadHash{%key}[%i]->$getInfo(packName) == $1)
					{
						return %key|||%i;
					}
				}
			}
		}
		return $false;
	}
	
	function searchDLHSTForBot(searches a specified downloadHash searchTerm for a botname)
	{
		/* this function searches a specified downloadHash{searchTerm} array for a botName.
		
			The downloadHash holds arrays of xdccobjects in the format:
		
				downloadHash{searchTerm}[i]->xdccobject
		
			This function searches all of the array entries (signified by [i] above) of a specified searchTerm in the downloadHash.
		
			Parameters: 
		
				$0 - searchTerm (string)	- the searchTerm entry to search in
				$1 - botName (string)		- the botName to search for in the array of xdccobjects
		
			Returns: 
			
				success: (integer)		- will return the index number that the botName can be found in
				failure: (boolean)		- will return $false if the botName or the searchTerm is not found
		
			Important: 
		
				When testing the return value from this array, you ___MUST___ check the typeOf the returned value to be boolean 
				because 0 is a valid return value for a success!
		*/
		
		%searchTerm = $0
		%botName = $1
		%success = $false
		
		
		if (%searchTerm != "" && %botName != "")
		{
			if ($typeOf(%G_hushDownloadHash{%searchTerm}) == array)
			{
				# loop through searchTerm array and check if any of the xdccobjects in the array have the botName we're looking for
				for (%i = 0; %i < $length(%G_hushDownloadHash{%searchTerm}); %i++)
				{
					if (%G_hushDownloadHash{%searchTerm}[%i]->$getInfo(botName) == %botName)
					{
						%success = %i
						break;
					}
				}
			}
			else
			{
				# searchterm was not found in the downloadHash, or there is no array for that searchTerm - debug output
			}
		}
		else
		{
			# arguments not supplied - debug output
		}
		
		return %success
	}
	
	function getDownloadInfoArray(returns an array of $0 values from xdccobject->%info{$0} if $1 matches $2)
	{
		/* This function will return an array of values from the hushdownloadHash
		'info bit' - an object member of the xdccobject. see xdccobject class constructor for info bit names
		This function: 
		 checks for existence of $1 info bit, if it exists
		 checks if the _value_ of the $1 info bit is contained in $2 (you can compare an array or csv string of values), if $2 contains $1 info bit's _value_
		 adds the _value_ of the $0 info bit to the return array
		 else outputs debug messages and returns false
		
		Parameters:
		 $0 - (string) name of info to return in array
		 $1 - (string) name of info for conditional check
		 $2 - (string) value to look for in $1
		
		Example:
		 $0 - searchTerm
		 $1 - status
		 $2 - Queued,Failed,Aborted
		 This will check if xdccobject's status info bit is contained in $2 (so if the status is "Queued" it will match.
		 The xdccobject's searchTerm info bit _value_ is returned
		*/
		
		%n = 0
		if (%G_hush->%debug) {debug -c we are checking for objects with '$1' that contains '$2' and are returning the value found in '$0';}
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			for (%i = 0; %i < $length(%G_hushDownloadHash{"%key"}); %i++)
			{
				%check = %G_hushDownloadHash{%key}[%i]->$getInfo($1)
				if (%check)
				{
					if ($str.contains($2,%check))
					{
						%str = %G_hushDownloadHash{"%key"}[%i]->$getInfo($0)
						if (%str)
						{
							%r[%n] = %str
							%n++;
						}
						else
						{
							if (%G_hush->%debug) {debug -c Requested info item '$0' was not found in %key|||%i oops!;}
						}
					}
				}
				else
				{
					if (%G_hush->%debug) {debug -c Requested info item '$1' for search comparison was not found in %key|||%i oops! (The previous oops from xdccobject::getInfo was triggered by this function);}
				}
			}
		}
		if ($length(%r) < 1) {%r = $false;}
		return %r;
	}
	
	function editDHAutos(alters all entries in the download hash that are marked as automatic downloads. param 0: info name 1: value)
	{
		/* This function will mass edit any entries in the downloadHash that have the autoDownload info set to true.
		
		dev-note: this is exclusively used to change all queue items to be requested via SSL. If the user has queued items and they tick
				the option to request packs via SSL in the mean time, this function will update all queued, automatic download items 
				to be requested via SSL.
		
		$0 - name of info bit to alter (see xdccobject constructor for details)
		$1 - value to assign to info bit
		*/
		
		%total = 0;
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			for (%i = 0; %i < $length(%G_hushDownloadHash{"%key"}); %i++)
			{
				if (%G_hushDownloadHash{%key}[%i]->$getInfo(autoDownload))
				{
					%G_hushDownloadHash{%key}[%i]->$setInfo($0, $1)
					%total++;
				}
			}
		}
		if (%total > 0) {return %total;} else {return $false;}
	}
	
	function doPassiveSearch($0 - boolean: if true, means the passive search was triggered automatically. false means it was triggered manually.)
	{
		if (%G_hushOptions{"NoiseNone"}) {%speak = $false;} else {%speak = $true;}
		if (%G_hush->%debug) {debug -c Passive search callback began;}
		
		@$buildPSQuery()
		%query = %G_hush->%PSQuery
		
		# fetch botPriority array from botstats table
		%botPriority = @$botStats(getPriority)
		if ($typeOf(%botPriority) == boolean && %botPriority == $false)
		{
			if (@%debug) {debug -c $b()Error$b(): botPriority array was false. Halting doPassiveSearch execution. (Check botStats[getPriority] data);}
			halt;
		}
		
		#debug -c %query
		# check if sql connection exists, make it if it doesnt, halt if it fails.
		if (%G_hush->%sql->$className != sql)
			if (!%G_hush->$dbConnect())
			{
				if (@%debug) {debug -c $b()Error$b(): connection to hush database failed. Halting doPassiveSearch execution. $k(4)Error was: @%sql->$lastError($true)$k();}
				halt;
			}
		
		# fetch results from database
		%G_hush->%sql->$queryPrepare(%query)
		if (%G_hush->%sql->$queryExec(%query))
		{
			%G_hush->$updateValues()
			%total = 0;
			%queryUpsert = "INSERT OR REPLACE INTO haystack (%G_hush->%iDBFields) VALUES "
			%zncMsg = "Hush Passive Search found the following at $date(F T): "
			%fcwMsg = $k(5)$b()Passive Search at $date(F T) found$b()$k()\n;
			do {
				%row = %G_hush->%sql->$queryRecord();	
				if (%row{"packName"})
				{
					# output row data to FCW
					if (%G_hushOptions{"SSL"}) 
					{
						%dccString = "|$cr![!rbt]xdcc::hilightsClick %G_hush->%ircContexts{"%row{"networkName"}"} \"%G_hushOptions{"FCW"}\" SSEND %row{"botName"} %row{"packName"} %row{"packNum"} %row{"packGets"} %row{"packSize"}$cr()$k(10)SSL$k()$cr()"
					}
		# dev-note: this is the line that prints to FCW for each found passive search result
					%fcwMsg .= [$cr![!rbt]xdcc::hilightsClick %G_hush->%ircContexts{"%row{"networkName"}"} \"%G_hushOptions{"FCW"}\" SEND %row{"botName"} %row{"packName"} %row{"packNum"} %row{"packGets"} %row{"packSize"}$cr()$k(10)DCC$k()$cr()%dccString]$k(4)$b()%row{"packName"}$b()$k()\n[%row{"channelName"}][Bot: %row{"botName"}][Pack Num: #%row{"packNum"}][Gets: %row{"packGets"}x][Size: %row{"packSize"} bytes]\n
					# builds haystack upsert values
					%queryUpsert .= (\'%row{"timestamp"}\',\'%row{"networkName"}\',\'%row{"channelName"}\',\'%row{"botName"}\',\'%row{"packNum"}\',\'%row{"packGets"}\',\'%row{"packSize"}\',\'%row{"packName"}\'), 
					%total++;
					%zncMsg .= %row{"packName"}", "
					# this code block adds xdccObjects to the download hash when passive search finds them
					# dev-note: this portion of code doesn't trigger auto downloading. it is just building the data the auto-downloading system uses, because all the needed data is here now. take a look further down for where the auto downloading is actually triggered (lol triggered)
					for (%i = 0; %i < %G_hushSearches[]#; %i++)
					{
						if ($str.grep(%G_hushSearches[%i],%row{"packName"}, w))
						{
		# dev-note: %sendStyle is temporary only, we need to decide if auto downloads are ssl or not
							%sendStyle = SEND
							if (%G_hushOptions{"TransfersSSLAuto"} && $str.grep(%row{"botName"},%G_hush->%arrayBotsNoSSL) == $false) {%sendStyle = SSEND;}
							%thisDL = %G_hush->$searchDownloadHash(%row{"botName"},%row{"packName"})
							if (%thisDL)
							{
								%thisDL = $str.split(|||,%thisDL,2)
								# update the info for this passive search result in the downloadHash because there's already a matching entry for it
								%G_hushDownloadHash{"%thisDL[0]"}[%thisDL[1]] = $new(hush::xdccobject,0,$null,%row{"networkName"},%row{"channelName"},%row{"botName"},%row{"packName"},%row{"packNum"},%row{"packGets"},%row{"packSize"},Queued,%thisDL[0],%sendStyle,$true)
								if (!$str.grep(%thisDL[0],%G_hush->%downloadOrder))
								{
									%G_hush->%downloadOrder[%G_hush->%downloadOrder[]#] = %thisDL[0]
								}
								%G_hush->%queueeditor->$refreshQueue()
								break;
							}
							else
							{
								# create a new entry for this passive search result in the downloadHash because it's new
								%st = %G_hushSearches[%i]
								%di = $length(%G_hushDownloadHash{%st})
								%G_hushDownloadHash{%st}[%di] = $new(hush::xdccobject,0,$null,%row{"networkName"},%row{"channelName"},%row{"botName"},%row{"packName"},%row{"packNum"},%row{"packGets"},%row{"packSize"},Queued,%G_hushSearches[%i],%sendStyle,$true)
								if (!$str.grep(%st,%G_hush->%downloadOrder))
								{
									%G_hush->%downloadOrder[%G_hush->%downloadOrder[]#] = %st
								}
								%G_hush->%queueeditor->$refreshQueue()
								# set xdccobjects's category magically - defaults to "Other"
								%cat = 3
								if ($str.grep("S[0-9]{1,2}",%row{"packName"}, r) || $str.grep("season.[0-9]{1,2}",%row{"packName"}, r))
								{%cat = 5; if (%G_hush->%debug) {debug -c decided category as TV Shows;}}
								elseif ($str.rightfromlast(%row{"packName"},.) == mkv || $str.rightfromlast(%row{"packName"},.) == mp4 || $str.rightfromlast(%row{"packName"},.) == avi)
								{%cat = 1; if (%G_hush->%debug) {debug -c decided category as Movies;}}
								elseif ($str.rightfromlast(%row{"packName"},.) == pdf || $str.rightfromlast(%row{"packName"},.) == txt || $str.contains(%row{"packName"},\.EPUB) || $str.contains(%row{"packName"},eBook))
								{%cat = 0; if (%G_hush->%debug) {debug -c decided category as eBooks;}}
								elseif ($str.rightfromlast(%row{"packName"},.) == exe || $str.rightfromlast(%row{"packName"},.) == zip || $str.rightfromlast(%row{"packName"},.) == msi || $str.rightfromlast(%row{"packName"},.) == bin || $str.rightfromlast(%row{"packName"},.) == iso)
								{%cat = 4; if (%G_hush->%debug) {debug -c decided category as Software;}}
								elseif ($str.rightfromlast(%row{"packName"},.) == mp3 || $str.rightfromlast(%row{"packName"},.) == flac || $str.contains(%row{"packName"},[MP3) || $str.contains(%row{"packName"},.MP3) || $str.contains(%row{"packName"},[FLAC]) || $str.contains(%row{"packName"},"(FLAC)")  || $str.contains(%row{"packName"},-FLAC-))
								{%cat = 2; if (%G_hush->%debug) {debug -c decided category as Music;}}
								else
								{%cat = 3; if (%G_hush->%debug) {debug -c decided category as Other;}}
		
								%G_hushDownloadHash{%st}[%di]->%info{"mediaCategory"}->$setCurrentItem(%cat)
								break;
							}
						}
					}
				}
			}
			while (%G_hush->%sql->$queryNext());
		
		# sort downloadHash using the botPriority array
			%G_hushDownloadHash = @$sortDHByPriority(%botPriority)
		
			%fcwMsg .= $k(5)$b()--------------------$b()$k();
		### message outputs to user (FCW and ZNC)
			%zncMsg = $str.chop(%zncMsg,2)
			%zncMsg .= ". %total packs found in this search."
			if (%G_hush->%debug) {debug -c Total results found: %total;}
			if (%total > 0)
			{
				if (%speak) 
				{
					%G_hush->$doFCW(); 
					echo -w=$window(%G_hushOptions{"FCW"}) %fcwMsg; 
					echo -w=$window(%G_hushOptions{"FCW"}) This was in hush::doPassiveSearch - speak = %speak;
				}
				%queryUpsert = $str.chop(%queryUpsert,1)";"
				if (%G_hush->%sql->$queryExec(%queryUpsert))
				{
					if (%G_hush->%debug) {debug -c Successfully upserted to haystack.;}
				}
				else
				{
					if (%G_hush->%debug) {debug -c Upsert to haystack failed. Error given: %G_hush->%sql->$lastError($true);}
				}
				if (%G_hushOptions{"ZNCPush"})
				{
					# dev note - you cant send newline chars in ZNC push messages. IRC spec breaks commands on newlines. it sucks
					# dev note - the code that handles *push query window prevention (ie: %G_hushOptions{"ZNCPreventQuery"}) is located in Events::onQueryMessage
					%network = %row{"networkName"}
					msg -q -r=$console(%G_hush->%ircContexts{"%network"}) *push send %zncMsg
					# output debug message
					if (%G_hush->%debug) {debug -c "zncpush: pushed notification for %total results found in passive search";}
				}
				# dev-note: realize that xdcc::doNextAutoDownload checks if auto downloads is turned on or not and acts accordingly
				xdcc::doNextAutoDownload
			}
		### end message outputs (FCW and ZNC) code
		}
		else
		{
			if (%G_hush->%debug) {debug -c No matches found for passive search.;}
		}
	}
	
	function doFCW(checks if FCW exists, creates it if it doesn't)
	{
		# this function will check if the Found Content Window exists, if it doesn't it will create it.
		# this function will usually be called before any code that outputs to the FCW.
		
		# if hilight window doesn't exist
		if (!$window.exists($window(%G_hushOptions{"FCW"})))
		{
			if (@%debug) {debug -c info: FCW doesn't exist so creating;}
			$window.open("mq", %G_hushOptions{"FCW"},0,305)
		}
	}
	
	function destructor(runs when hush::main object is being destroyed)
	{
		# this code block should run when the hush::main object is destroyed
		# desctruction should only occur on kvirc shutdown and on script uninstall
		# we need to get the hush global values destroyed on uninstall just to ensure all data is reset
		
		%temp = $window(%G_hushOptions{"FCW"})
		if ($window.exists(%temp)) { window.close -w %temp;}
		@%sql->$closeConnection();
		
		@%sql = $null
		
		@$configSave(@%hushConfig, searches, %G_hushSearches)
		@$configSave(@%hushConfig, exceptions, %G_hushSExceptions)
		@$configSave(@%hushConfig, options, %G_hushOptions)
		@$configSave(@%hushConfig, channels, %G_hushWatchChannels)
		@$configSave(@%hushConfig, botsNoSSL, %G_hush->%arrayBotsNoSSL)
		
		delete -q %G_hush->%channels
		delete -q %G_hush->%common
		delete -q %G_hush->%instantsearch
		delete -q %G_hush->%library
		delete -q %G_hush->%libraryoptions
		delete -q %G_hush->%options
		delete -q %G_hush->%queueeditor
		delete -q %G_hush->%searches->%import
		delete -q %G_hush->%searches
		
		unset %G_hushDownloadHash
		unset %G_hushLive
		unset %G_hushOptions
		unset %G_hushSearches
		unset %G_hushSExceptions
		unset %G_hushWatchChannels
		unset %G_hush
	}
	
	function debugThis(show something about this object for debugging)
	{
		# output contents of %G_hushOptions into debug window
		%o = \n
		
		if ($str.match($0,"Options"))
		{
			foreach (%key, $keys(%G_hushOptions))
				%o .= "%key = %G_hushOptions{"%key"}\n"
		}
		elseif ($str.match($0,"DownloadHashSize, HashSize, DownloadSizes"))
		{
			%t = 0
			foreach (%key, $keys(%G_hushDownloadHash))
			{
				%n = $length(%G_hushDownloadHash{"%key"})
				%o .= "length(%key) = %n\n"
				%t += %n
			}
			%o .= "Total %t items in G_hushDownloadHash\n"
		}
		elseif ($str.match($0,ActiveDownloads))
		{
			%ad = @$getDownloadInfoArray(packName,status,"Receiving")
			if ($typeOf(%ad) == array)
			{
				%o .= $k(8)There are %ad[]# active downloads:$k() \n;
				for (%i = 0; %i < %ad[]#; %i++) {%o .= %ad[%i]\n;}
			}
			else {debug -c ad = %ad; %o .= There are no active downloads. Checked $length(%G_hushDownloadHash) searchTerm entries in downloadHash.;}
		}
		elseif ($str.match($0,CanceledDownloads))
		{
			%ad = @$getDownloadInfoArray(packName,status,"Cancelled")
			if ($typeOf(%ad) == array)
			{
				%o .= $k(8)There are %ad[]# cancelled downloads:$k() \n;
				for (%i = 0; %i < %ad[]#; %i++) {%o .= %ad[%i]\n;}
			}
			else {debug -c ad = %ad; %o .= There are no cancelled downloads. Checked $length(%G_hushDownloadHash) searchTerm entries in downloadHash.;}
		}
		else
		{
			%o .= "I don't know what to show you for '$0'?"
		}
		
		debug -c %o
	}
	
	function dbDisconnect()
	{
		if (@%sql->$closeConnection(hushdb))
		{
			if (@%debug == $true) {debug -c sql connection closed;}
			return $true;
		}
		else
		{
			return $false;
		}
	}
	
	function dbCreate(creates a sqlite database file if it doesnt exist. $0 - boolean, set to true to delete the existing database before making new tables)
	{
		# this function will create an sqlite database file for hush in the kvirc locadir under hush's folder.
		
		# note: @%hushDatabase is defined in the hush class constructor
		
		# check if database file exists already
		if (@%debug == $true) debug -c we are in hush::dbCreate
		
		if ($0 == $true && $file.exists(@%hushDatabase))
		{
			# delete file if it exists
			file.remove @%hushDatabase
		}
		
		# database does not exist, need to create
		if (@%debug) debug -c Attempting to create new database file at @%hushDatabase
		@%sql = $new(sql)
		if (@%sql->$setConnection(@%hushDatabase, hushdb))
		{
			if (@%debug) debug -c sql connection was success
			# instant search/main hush table (holds all the pack announce data)
			%q = "CREATE TABLE instant (timestamp text NOT NULL, networkName text NOT NULL, channelName text NOT NULL, botName text NOT NULL, packName text NOT NULL, packSize text NOT NULL, packNum integer NOT NULL, packGets integer);"
			if (@%sql->$queryExec(%q))
			{
				if (@%debug) {debug -c $k(7)database table created: $k(8)'instant'$k();}
				# haystack table (holds data for smarter searching)
				%q = "CREATE TABLE haystack (timestamp text NOT NULL, networkName text NOT NULL, channelName text NOT NULL, botName text NOT NULL, packName text NOT NULL, packSize text NOT NULL, packNum integer NOT NULL, packGets integer);"
				if (@%sql->$queryExec(%q)) {if (@%debug) {debug -c $k(7)database table created: $k(8)'haystack'$k();}}
				# bot statistics table (holds data about transfer success/failure rates from individual bots)
				%q = "CREATE TABLE botstats (networkName text NOT NULL, channelName text NOT NULL, botName text NOT NULL, transfersTotal integer NOT NULL, transfersSuccess integer NOT NULL, speedBest integer, speedAverage integer);"
				if (@%sql->$queryExec(%q)) {if (@%debug) {debug -c $k(7)database table created: $k(8)'botstats'$k();;}}
				%q = "PRAGMA journal_mode = OFF;\nPRAGMA temp_store = MEMORY;\nPRAGMA synchronous = OFF;"
				@%sql->$queryExec(%q)
			}
			else	
				if (@%debug) debug -c table creation failed, error given: @%sql->$lastError($true)
		}
		else
			if (@%debug) debug -c sql connection failed, error given: @%sql->$lastError($true)
	}
	
	function dbConnect()
	{
		if (!$objects.exists(@%sql))
		{
			if (@%debug) debug -c sql object does not exist. has main::dbCreate been called yet?
			return $false;
		}
		
		if (!@%sql->$setConnection(@%hushDatabase, hushdb))
		{
			if (@%debug) debug -c sql connection failed, error given: @%sql->$lastError()
			return $false;
		}
		else
		{
			if (@%debug) debug -c sql connection succeeded
			return $true;	
		}
	}
	
	function dbClearTable(clear the contents of a database table)
	{
		# this function will clear the contents of a sqlite database table
		# $0 = table name to be cleared
		
		if ($0)
		{
			# we will assume that the database connection is up already
			%query = "DELETE FROM $0;"
			# fetch results from database
			@%sql->$queryPrepare(%query)
			if (@%sql->$queryExec(%query))
			{
				if (@%debug) {debug -c Haystack table has been reset;}
				return $true;
				%query = "VACUUM;"
				@%sql->$queryPrepare(%query)
				@%sql->$queryExec(%query)
			}
			else
			{
				if (@%debug) {debug -c Haystack clearance was unsuccessful. Error given: @%sql->$lastError($true);}
				return $false;
			}
		}
		else
		{
			if (@%debug) {debug -c no table name was passed to this function. we can't clear a table if we don't klnow which one to clear. this is a probably a bug!;}
			return $false;
		}
		return $false;
	}
	
	function constructor(initializes widgets for the main hush window)
	{
		# hush::constructor
		# creates widget objects and member values for the hush Main window, initializes a lot of things
		
		
		if (@%debug) {debug -c info: building main widget;}
		
		@%arrayBotsNoSSL = $array
		@%common = $new(hush::common, $$, "Hush Common Functions Object")
		@%dbgI = 0
		@%debug = $false
		@%downloadOrder = $array
		@%hashAutoDownload = $null
		@%hushChannelPriority = $file.localdir("config/Hush/channelPriority.conf")
		@%hushConfig = $file.localdir("config/Hush/hush.conf")
		@%hushDatabase = $file.localdir("config/Hush/hushdb.sqlite")
		@%hushMediaCentres = $file.localdir("config/Hush/mediaCentres.conf")
		# csv string that holds the database fieldnames -> used in Events->onChannelMessage->hushInstantDatabase event handler (and now other places)
		@%iDBFields = "timestamp,networkName,channelName,botName,packNum,packGets,packSize,packName"
		@%iDBMaxCounter = 0
		@%ircContexts = $null
		@%scriptName = "Hush"
		@%searchImportsAutoFlag = $false
		@%version = "0.4.0"
		
		# database stuff must come after the member property declarations
		@$dbCreate();
		@$dbConnect();							# dev note: @%sql is created in $dbCreate
		
		# load config from disk if available
		if (@%debug) {debug -c reading settings from @%hushConfig;}
		%G_hushWatchChannels = @$configLoad(@%hushConfig, channels)
		%G_hushSearches = @$configLoad(@%hushConfig, searches)
		%G_hushSExceptions = @$configLoad(@%hushConfig, exceptions)
		%G_hushOptions = @$configLoad(@%hushConfig, options, hash)
		%G_hushDownloadHash = $hash
		@%arrayBotsNoSSL = @$configLoad(@%hushConfig, botsNoSSL)
		
		# hush live values
		# TransfersActive is an integer that tells us how many active transfers Hush has going
		%G_hushLive{"iTransfersActive"} = 0
		
		@$updateValues()
		
		@%l0 = $new(layout, $$)
		@%l0->$setSpacing(3)
		
		@$setGeometry(0,0,500,400)
		@$setWindowTitle("Hush v@%version")
		@$centerToScreen()
		
		### child widgets for Main
		
		# instant search lineedit
		@%leIS = $new(lineedit, $$)
		@%leIS->$setToolTip("Instant Search: type query and press enter")
		#@%leIS->$setBackgroundColor(eeeeee)
		@%leIS->$setForegroundColor(cccccc)
		@%leIS->$setText(Instant Search)
		
		# group box for messages
		@%grpMessages = $new(groupbox, $$)
		@%grpMessages->$setFocus()
		@%grpMessages->$setTitle("Welcome")
		@%grpMessages->$setFlat(0)
		@%grpMessages->$setAlignment(HCenter)
		@%grpMessages->$setMinimumHeight(250)
		
		@%grpMessages->$setOrientation(Vertical)
		# Label to get user started
		@%lblHomeMsg = $new(label, @%grpMessages)
		%lblHome = "Manage your watched channels, searches, options and media library settings using the buttons below.<br/><br/>Press Ctrl+Alt+I for Instant Search window.<br/><br/><b>Hover the mouse for tooltips.</b><br/><br/>For more information about and help with Hush, see the information section."
		if (@%debug)
		{
			%lblHome .= "<br/><br/>Debug mode is on. This is a test. <a href=\"http://www.google.com/\">Google</a> Some interesting values: "
			%lblHome .= "<br/>G_hushLive{iTransfersActive} = %G_hushLive{"iTransfersActive"}"
			%lblHome .= "<br/>G_hushHaystack size = %G_hushHaystack[]#"
			%lblHome .= "<br/>G_hushDownloadHash size = $length(%G_hushDownloadHash)"
			@%lblHomeMsg->$setAlignment(Top)
		}
		else
		{
			@%lblHomeMsg->$setAlignment(VCenter)
		}
		@%lblHomeMsg->$setText(%lblHome)
		
		# group box for settings
		@%grpSettings = $new(groupbox, $$)
		@%grpSettings->$setTitle("Settings")
		@%grpSettings->$setFlat(0)
		@%grpSettings->$setOrientation(Horizontal)
		# Settings -> Channels Button
		@%btnChannels = $new(button, @%grpSettings)
		@%btnChannels->$setText("Channels")
		@%btnChannels->$setTooltip("Click to modify which channels Hush should watch")
		# Settings -> Searches Button
		@%btnSearches = $new(button, @%grpSettings)
		@%btnSearches->$setText("Searches")
		@%btnSearches->$setTooltip("Click to modify what Hush is looking for in the watched channels")
		# Settings -> Options Button
		@%btnOptions = $new(button, @%grpSettings)
		@%btnOptions->$setText("Options")
		@%btnOptions->$setTooltip("Click to see additional options")
		# Settings -> Media Library Button
		@%btnMLibrary = $new(button, @%grpSettings)
		@%btnMLibrary->$setText("Media Library")
		@%btnMLibrary->$setTooltip("Click to open Media Library settings")
		
		
		# group box for information
		@%grpInfo = $new(groupbox, $$)
		@%grpInfo->$setTitle("Information")
		@%grpInfo->$setFlat(0)
		@%grpInfo->$setOrientation(Horizontal)
		# Information -> About Button
		@%btnAbout = $new(button, @%grpInfo)
		@%btnAbout->$setText("About Hush")
		@%btnAbout->$setTooltip("Click to find out what Hush does")
		# Information -> Help Button
		@%btnHelp = $new(button, @%grpInfo)
		@%btnHelp->$setText("Help")
		@%btnHelp->$setTooltip("Click to get additional help")
		# Information -> Change Log Button
		@%btnChLog = $new(button, @%grpInfo)
		@%btnChLog->$setText("Change Log")
		@%btnChLog->$setTooltip("Click to see the Change Log")
		
		# do layout
		@%l0->$addMultiCellWidget(@%leIS, 0,0,0,0)
		@%l0->$addMultiCellWidget(@%grpMessages, 1,1,0,0)
		@%l0->$addMultiCellWidget(@%grpSettings, 2,2,0,0)
		@%l0->$addMultiCellWidget(@%grpInfo, 3,3,0,0)
		
		### timer for instant search to start on hushMain creation
		@%tmrISStart = @$startTimer(1000)
		
		### timer handlers
		privateimpl($$, timerEvent)
		{
			@%instantsearch = $new(hush::instantsearch, 0, "Hush Instant Search widget")
			@$killtimer(@%tmrISStart)
		}
		
		### private impls
		privateimpl($$, closeEvent)
		{
			# close event of hush main window means we should save all hush values to disk
			@$configSave(@%hushConfig, searches, %G_hushSearches)
			@$configSave(@%hushConfig, exceptions, %G_hushSExceptions)
			@$configSave(@%hushConfig, options, %G_hushOptions)
			@$configSave(@%hushConfig, channels, %G_hushWatchChannels)
			@$configSave(@%hushConfig, botsNoSSL, %G_hush->%arrayBotsNoSSL)
		}
		
		# instant search query box gains focus
		privateimpl(@%leIS, focusInEvent)
		{
			if (@$text == "Instant Search") 
			{
				@$clear()
				@$setForegroundColor("000000")
			}
		}
		
		# instant search query box loses focus
		privateimpl(@%leIS, focusOutEvent)
		{
			if (@$text == "")
			{
				@$setForegroundColor("cccccc")
				@$setText(Instant Search)
			}
		}
		
		# instant search query box has key pressed
		privateimpl(@%leIS, keyPressEvent)
		{
			if ($0 == "Return")
			{
				# make sure instantsearch widget is existing
				if (!$objects.exists(%G_hush->%instantsearch))
					return $false;
				# set the instantsearch->leIS text value to the content of @%leIS (this object's instantsearch query)
				%G_hush->%instantsearch->%leIS->$setText(@$text())
				%G_hush->%instantsearch->$fnLaunchSearch(@$text())
				%G_hush->$showInstantSearch()
			}
		}
		
		privateimpl(@%btnAbout, mousePressEvent)
		{
			@$parent->$parent->$showAbout()
		}
		
		privateimpl(@%btnChLog, mousePressEvent)
		{
			@$parent->$parent->$showChangelog()
		}
		
		privateimpl(@%btnChannels, mousePressEvent)
		{
			@$parent->$parent->$showChannels()
		}
		
		privateimpl(@%btnHelp, mousePressEvent)
		{
			@$parent->$parent->$showHelp()
		}
		
		privateimpl(@%btnOptions, mousePressEvent)
		{
			@$parent->$parent->$showOptions()
		}
		
		privateimpl(@%btnSearches, mousePressEvent)
		{
			@$parent->$parent->$showSearches()
		}
		
		privateimpl(@%btnMLibrary, mousePressEvent)
		{
			@$parent->$parent->$showLibraryOptions()
		}
	}
	
	function configSave(saves all Hush values to the config file - $0 = file to save to, defaults to @%hushConfig $1 = section name $2 = values array)
	{
		# save all Hush values to the config file
		
		# note that this function should automatically adjust for any new option values you add in the future
		
		# check if a filename was passed to this function, if nothing was passed here, use @%hushConfig by default
		if ($0 == "")
			%outFile = @%hushConfig
		else
			%outFile = $0
		
		if ($1 == "") {if (@%debug) {debug -c Nope: second parameter 'section' is empty (required value) - no section name available to write to;} return false;}
		else {%section = $1;}
		if ($2 == $null) {if (@%debug) {debug -c Nope: third parameter 'values' is null (required value) - no values in array to read from;} return false;}
		else {%values = $2;}
		
		# open config for read and write
		%conf = $config.open(%outFile, rw)
		
		if ($isSet(%conf))
		{
		#	if (@%debug) debug -c info: writing %section values to file: %outFile
			if ($typeOf(%values) == hash)
			{
				# write options to config from hash
		#		if (@%debug) debug -c %section are stored as a hash in memory, writing to config
				config.clearsection %conf %section
				config.setsection %conf %section
				if ($isSet(%values))
				{
					foreach (%key, $keys(%values))
						config.write %conf %key %values{"%key"}
				}
			}
			if ($typeOf(%values) == array)
			{
				# write options to config file from array
		#		if (@%debug) debug -c %section are stored as an array in memory, writing to config
				config.clearsection %conf %section
				config.setsection %conf %section
				if ($isSet(%values))
				{
					for (%i = 0; %i <= $($length(%values) - 1); %i++)
						config.write %conf %i %values[%i]
				}
			}
			config.close %conf
			return $true
		}
		else 
		{
		#	if (@%debug) debug -c Nope: Could not open config file for writing. Config file path: @$hushConfig
			return $false
		}
		# end of config write
	}
	
	function configLoad(load Hush values from config file on disk - $0 = file to load from, defaults to @%hushConfig $1 - section name $2 - hash this argument is optional. send string 'hash' if you want the loaded settings inside a hash instead of an array)
	{
		# load Hush values from config file on disk
		
		# check if a filename was passed to this function, if nothing was passed here, use @%hushConfig by default
		if ($0 == "")
			%inFile = @%hushConfig
		else
			%inFile = $0
		
		if ($1 == "") { if (@%debug) {debug -c Nope: second parameter 'section' is empty (required value) - no section name avaiable to read from;} return false;}
		else {%section = $1;}
		
		# open config
		%conf = $config.open(%inFile, r)
		
		if ($isSet(%conf))
		{
			if (%section != "")
			{
				if (@%debug) {debug -c info: reading %section values;}
				config.setsection %conf %section
				if ($2 != hash)
				{
					# calling code does not want a hash, so return an array
					# read the values from config file for current section
					%values = $config.keylist(%conf)
					foreach(%i, %values)
						%return[%i] = $config.read(%conf, %i)
				}
				else
				{
					# calling code requests a hash as the return value
					%values = $config.keylist(%conf)
					foreach(%key, %values)
						%return{"%key"} = $config.read(%conf, %key)
				}
			}
			else
			{
				if (@%debug) {debug -c Nope: no section name was passed (required) cant read values without a section name.;}
				return $false
			}
			config.close %conf
			return %return
		}
		else
		{
			if (@%debug) {debug -c Nope: Could not open config file for reading. Config file path: @$hushConfig;}
			return $false
		}
	}
	
	function checkHushIsOn(returns true or false if hush is on or not)
	{
		# this function will check if we have all the needed data for Hush to be operating
		# this function will be called by some event handlers to make sure we want to output a message to the user
		# probably it will be DCC Events (as a hint, if you are looking for what this is for ;)
		
		# check that Hush is watching some channels
		if (%G_hushWatchChannels[]# > 0)
		{
			# check that Hush is searching for something
			if (%G_hushSearches[]# > 0)
			{
				return $true
			}
			if (@%debug) debug -c info: no searches are set
		}
		if (@%debug) debug -c info: no channels to watch set
		return $false
	}
	
	function checkDownloadQueue(checks the download queue to see if there is another pack we want to download)
	{
		/* this function finds the searchTerm and index value that points to an xdccobject be downloaded from %G_hushDownloadHash
		the search term and index value are returned in the format: searchTerm|||index
		The searchTerm and index are used to access the xdccobject in the %G_hushDownloadHash hash table, like: 
		%G_hushDownloadHash{"searchTerm"}[index]
		
		dev-note: %G_hushDownloadHash keys are set to a value from the hush searches array as they are found by passive search
				(see: hush::main::timerPassiveSearch)
		
		this function will prolly get triggered (lol triggered) in the hush::main::timerPassiveSearch function callback code
		
		dev-note: the initial writing of this code will loop through the hushDownloadHash sequentially. If this ends up being inefficient, 
				 the next idea will be to check the first character in the %key value and loop from the start or the end depending on 
				 which side the first character likely will fall in. this should at worst halve the looping load.
		
		arguments:
		$0 - array - activeSearchTerms: an array containing the current active searchTerms in the downloadHash
		*/
		
		# note: statusContinue and statusStop <-- "continue" and "stop" is sepcifically referring to the loops below. if an xdccobject
		# status is in the Stop string, we want the loop to "stop" and return the entry!
		%activeST = $0
		%statusContinue = "Cancelled (Passive Bot), Cancelled (Unsupported Command), Complete, Connecting, Failed, IRC Network Unavailable, Previous Pack Completed, Receiving, Session Timed Out, User Aborted, User Cancelled, Wrong File, Waiting (RQ)"
		%statusStop = "Queued, Retrying"
		# append the statusStop string with the status for when bot says it doesnt support SSL if the user wants to allow non SSL auto downloads
		if (%G_hushOptions{"TransfersNoSSLOK"}) {%statusStop .= ", Cancelled (No SSL)";}
		
		# loop through the downloadHash
		foreach (%key, $keys(%G_hushDownloadHash))
		{
			# loop through the searchTerm array in the downloadHash
			for (%i = 0; %i < $length(%G_hushDownloadHash{"%key"}); %i++)
			{
				# match the search term
				if (%G_hushDownloadHash{"%key"}[%i]->$getInfo(searchTerm) == %key)
				{
					# check if %activeST is true (activeSearchTerms array)
					if (%activeST) 
					{
						# check that the current key (searchTerm) doesn't exist in $0 (activeSearchTerms)
						if ($str.match(%key,%activeST))
						{
							# the break below will quit us from the current for loop, which is specific to the %key (searchTerm) value
							if (@%debug) {debug -c autoDownloadControl: found searchTerm $b()%key$b() already has an active download for it, so skipping this searchTerm;}
							break;
						}
					}
					# check the status is in statusStop (stop the loop and return the value)
					if ($str.match(%G_hushDownloadHash{"%key"}[%i]->$getInfo(status),%statusStop))
					{
						# check the transfer attempt value is smaller than the maxRetries value
						if (%G_hushDownloadHash{"%key"}[%i]->$getInfo(attempts) <= $(%G_hushOptions{"TransfersMaxRetries"} + 1))
						{
							# this is the first entry that matches the search term, has a status to be dowloaded and has retries left
							if (@%debug) {debug -c hushDownloadHash{%key}[%i] has status: %G_hushDownloadHash{"%key"}[%i]->$getInfo(status) (would we want to auto download this? i think we might);}
							return %key|||%i
						}
					}
				}
			}
		}
		return $false
	}
	
	function buildPSQuery(builds the passive search query string from the searches array)
	{
		# this query hopefully pulls pack data from the database based on our passive searches array
		# dev note: the sqlite query built here
		/*
			selects rows from table instant
			compared against (inner join) a selection based on packName, botName, and MAX(timestamp) to find the most recent entries
			where packName contains anything in the searches array and doesnt contains anything in the exceptions array
			and (where) the row doesnt exist in a selection from the haystack table based on packName, packNum and packSize
			grouped by botName then packSize
			ordered by packName
		*/
		
		@%PSQuery = "SELECT t1.* FROM instant t1 INNER JOIN (SELECT packName, botName, MAX(timestamp) AS maxtimestamp FROM instant GROUP BY timestamp, botName) AS t2 ON t1.packName = t2.packName AND t1.timestamp = t2.maxtimestamp AND t1.botName = t2.botName WHERE "
		for (%i = 0; %i < %G_hushSearches[]#; %i++)
		{
			@%PSQuery .= "(t2.packName LIKE '$str.replace(%G_hushSearches[%i],"*","%")') || "
		#	@%PSQuery .= $str.replace(%G_hushSearches[%i],*," ")" OR "
		}
		@%PSQuery = $str.chop(@%PSQuery,4)
		
		%searchExceptions = $null
		for (%i = 0; %i < %G_hushSExceptions[]#; %i++)
		{
			%sx = %G_hushSExceptions[%i]
			%sx = $str.replace(%sx, "*", "%")
			%sx = $str.replace(%sx, " ", "%")
			%sx = $str.replace(%sx, "?", "_")
			%searchExceptions .= "AND (t2.packName NOT LIKE '\%%sx\%')";
		}
		
		@%PSQuery .= " %searchExceptions AND NOT EXISTS (SELECT * FROM haystack t3 WHERE t1.packName = t3.packName AND t1.packNum = t3.packNum AND t1.packSize = t3.packSize) GROUP BY t1.botName, t1.packSize ORDER BY t1.packName;"
		if (@%debug) 
		{
			debug -c Built Passive Search query string with %G_hushSearches[]# searches and %G_hushSExceptions[]# exceptions.;
		}
	}
	
	function buildActiveSearchTermArray(builds an array that contains all the active search terms in the auto download system)
	{
		# build the active search terms array because transfer status just changed
		
		# fetch which searchTerms in the downloadHash have an active item
		%activeStatuses = $array(Requested,Receiving,Downloading,Connecting)
		%G_hush->%activeSearchTerms = %G_hush->$getDownloadInfoArray(searchTerm,status,%activeStatuses)
	}
	
	function botStats(handles all operation related to the bot styatistics system)
	{
		/* botStats - this function will handle any operations hush needs to do with the bot statistics system.
			the botstats system uses the 'botstats' table in the hush sqlite database.
		
		parameters
			$0 - action (string) tells this function what action we want to undertake. corressponds to a section below
				Supported actions are:
					exists 	 - checks if a bot has an existing record in the botstats table. 
							   returns true if it exists, else returns false.
		
					getPriority - builds the SQL query to retrieve auto download priority bot data from hush database.
							   returns an array of botNames in order of highest download priority to lowest. else returns false.
		
					update 	 - sends the SQL query to update a bot's transfer stats to the hush hdatabase. 
							   returns true if query exec succeeds, else returns false.
			$1 - varies depending on action
				
				parameter		type						action
				-----------------------------------------------------------------------------------
				query			(string) the SQL query to use	[exists, update]
		*/
		
		%action = $0
		%botName = $1
		%channelname = $2
		%networkName = $3
		%query = $1
		%success = $false
		
		switch (%action)
		{
			case(exists):
			{
				# checks if a bot has an existing entry in the botstats table
				if (%query)
				{
					# SQL query will be sent to us by the calling code (see events->onDCCTransfer handlers)
					@%sql->$queryPrepare(%query)
					if (@%debug) {debug -c EXISTS query is: %query;}
					if (@%sql->$queryExec(%query))
					{
						if (@%debug) {debug -c successfully sent the EXISTS query to the sqlite database;}
						@%sql->$queryFirst();
						%row = @%sql->$queryRecord();
						if ($typeOf(%row) == hash)
						{
							if (%row{"value"} >= 1) 
							{
								%success = $true;
								if (@%debug) {debug -c existing entry found in botstats table so we should update this entry not insert a new one;}
							}
							else
							{
								if (@%debug) {debug -c row{value} was not >= 1. value: %row{"value"};}
							}
						}
						else
						{
							# result row was null so no match was found, return false
							if (@%debug) {debug -c no existing entry found in botstats table\ntypeOf(row) = $typeOf(%row);}
						}
					}
					else
					{
						if (@%debug) {debug -c SQL query attempt failed. Error: $b()@%sql->$lastError($true)$b();}
					}
				}
				break;
			}
			case(getPriority):
			{
				# this action builds a SQL query to retrieve botNames from the bostats table sorted in automatic download priority order.
				# build SQL query
				%query = "SELECT\n"
		
				%priorityCase = "  CASE \n"
				%priorityWhens = ""
				%priorityEnd = "  END AS priority, \n"
				%priorityInt = 0
		
				%queryFields = "  botName,\n  CAST(transfersSuccess as real) / CAST(transfersTotal as real) AS percentSuccessful,\n  speedAverage\n"
					
				%whenChannels = $false
		
				%queryFrom = "FROM \n  botstats\n"
				%queryOrder = "ORDER BY \n"
		
				# success tiers - any prioritised channels will have its own entry in each success tier. 
				# The success tier value is how success a bot is at completing transfers expressed as a percent in decimal format. 1.0 = 100% success.
				# success tier values should always be in descending order and the last value will be used as the "anything below this" condition to make the lowest priority.
				# dev-note: 0.25 has two entries in the successTiers array because the first one is for >= condition and the second is for < condition
				%successTiers = $array(0.75,0.50,0.25,0.25);
		
				# build priority value based on Transfer Priority settings
				if (%G_hushOptions{"TransferPriorityToggle"})
				{
					%lines = @%options->%mleTPChannels->$lines
					if (%lines > 0)
					{
						%n = 0
						foreach (%succTierValue, %successTiers)
						{
							# check if this is the last value in %successTiers, adjust the comparison operator accordingly
							if (%n == $(%successTiers[]# - 1)) {%comparisonOp = "<";} else {%comparisonOp = ">=";}
		
							# loop through the channel names user has configure in options
							for (%i = 0; %i < %lines; %i++)
							{
								%line = @%options->%mleTPChannels->$textLine(%i)
								if (!$isEmpty(%line)) 
								{
									# prepend line with # (to catch users that don't put # at the start of the channel names)
									if ($str.find(%line, #) != 0) {%line = #%line;}
									%priorityWhens .= "    WHEN channelName = '%line' AND CAST(transfersSuccess as REAL) / CAST (transfersTotal as REAL) %comparisonOp %succTierValue THEN %priorityInt\n";
									%priorityInt++;
									%whenChannels = $true
								}
							}
							%priorityWhens .= "    WHEN CAST(transfersSuccess as REAL) / CAST (transfersTotal as REAL) %comparisonOp %succTierValue THEN %priorityInt\n";
							%priorityInt++;
							%n++;
						}
					}
					else
					{
						if (@%debug) {debug -c [getPriority] $b()no lines found in hush->options->mleTPChannels;}
					}
					if (%whenChannels) {%priorityCase << %priorityWhens %priorityEnd;} else {%priorityCase = "";}
				}
				else
				{
					%priorityCase = "";
				}
				# add priority ordering if we have it
				if (%whenChannels) {%queryOrder << "  priority ASC,\n";}
				# check speed vs success ordering setting
				if (%G_hushOptions{"TransferPrioritySpeedSuccess"}) 
				{
					%queryOrder << "  percentSuccessful DESC,\n  speedAverage DESC\;";
				}
				else 
				{
					%queryOrder << "  speedAverage DESC,\n  percentSuccessful DESC\;";
				}
				# put query together
				%query << %priorityCase %queryFields %queryFrom %queryOrder;
		#		if (@%debug) {debug -c [getPriority] $b()priority query$b() = \n%query;}
				
				# send query to database? return botName priority list/hash as return value?
		
				%success = %query;
		
				if (%query)
				{
					@%sql->$queryPrepare(%query)
					if (@%sql->$queryExec(%query))
					{
						if (@%debug) {debug -c [getPriority] successfully sent query to the sqlite database;}
						# build return array with order of botNames to give best priority to
						%returnArray = $array()
						%i = 0
						do {
							%row = %G_hush->%sql->$queryRecord()
							%returnArray[%i] = %row{"botName"}
							%i++
						}
						while (%G_hush->%sql->$queryNext());
						%success = %returnArray;
					}
					else
					{
						if (@%debug) {debug -c [getPriority] SQL query attempt failed. Error: $b()@%sql->$lastError($true)$b();}
					}
				}
				break;
			}
			case(update):
			{
				if (%query)
				{
					# SQL query will be sent to us by the calling code (see events->onDCCTransfer handlers)
					@%sql->$queryPrepare(%query)
					if (@%sql->$queryExec(%query))
					{
						%success = $true;
						if (@%debug) {debug -c successfully sent the UPDATE/INSERT query to the sqlite database;}
					}
					else
					{
						if (@%debug) {debug -c SQL query attempt failed. Error: $b()@%sql->$lastError($true)$b();}
					}
				}
				break;
			}
			default:
			{
				if (@%debug) {debug -c action type '%action' is unknown. no operations were executed.;}
				break;
			}
		}
		return %success
	}
	
}

class("hush::libraryoptions","widget")
{
	function getMediaType(returns an array of the indexs that hold listviewitem data for a particular media type in the library options, $0 = media type name, valid values are found in @%coboMediaLoc)
	{
		%mediatype = $0
		
		if (%mediatype == $null)
		{
			if (%G_hush->%debug) debug -c first parameter is null, required value 'mediatype' (string) is missing so returning false
			return $false
		}
		
		%lvi = @%lviMediaEntries
		for (%i = 0; %i <= @%lviMediaEntries[]#; %i++)
		{
			if (%lvi[%i] != $null)
			{
				if (%lvi[%i]->$className() == listviewitem)
				{
					if (%lvi[%i]->$text(1) == %mediatype)
					{
						# put the media entry index value into the return array
						%return[] = %i
					}
				}
				else
				{
					if (%G_hush->%debug) debug -c Oops! That listviewitem entry wasn't a listviewitem. Ignoring.
				}
			}
			else
			{
				if (%G_hush->%debug) debug -c Oops! That listviewitem entry was null. Ignoring.
			}
		}
		
		return %return
	}
	
	function getLoc(fetches the location associated with a category name)
	{
		# this function will return the path associated with a category name
		
		%cat = $0
		for (%i = 0; %i < @%lviMediaEntries[]#; %i++)
		{
			if (@%lviMediaEntries[%i]->$text(1) == %cat)
			{
				%loc = @%lviMediaEntries[%i]->$text(2)
				return %loc;
				break;
			}
		}
		
		if (%G_hush->%debug) {debug -c did not find any media locations for category %cat;}
		return $false;
	}
	
	function fnLVItoCSV($0 - listviewitem object)
	{
		# function will take a listviewitem object and return a serialized csv string from the lvi
		# exmaple usage: %csvlvi = @%fnLVItoHash(%lviObject)
		
		%lvi = $0
		if ($typeOf(%lvi) == hobject)
		{
			if (%lvi->$className() == listviewitem)
			{
				# @%lviCols contains the total number of columsn in the lvi (manually set in libraryoptions::constructor)
				for (%i = 0; %i < @%lviCols; %i++)
					%csv <, $serialize(%lvi->$text(%i));
		#		if (%G_hush->%debug) debug -c csv = %csv
				return %csv
			}
			else
			{
				# passed object is not a listviewitem
				if (%G_hush->%debug) debug -c Nope: value passed in first parameter is not listviewitem class. Class passed: %lvi->$className()
				return $false
			}
		}
		else
		{
			# passed object is not an object (possibly null)
			if (%G_hush->%debug) debug -c Nope: value passed in first parameter is not listviewitem class, in fact it is not even an object.
			return $false
		}
	}
	
	function fnCSVtoLVI($0 - comma seperated serialized string of values made by libraryoptions::fnLVItoCSV, $1 - listviewitem parent)
	{
		# take a string made by libraryoptions::fnLVItoCSV and turn it into a listviewitem
		# $1 needs to be a listview object because all listviewitem objects need to be assigned to a parent listview object
		%csv = $0
		%lvParent = $1
		
		if (%csv != $null)
		{
			if (%lvParent != $null)
			{
				if ($typeOf(%lvParent) == hobject && %lvParent->$className == listview)
				{
					# split the string on ","
					%pieces = $str.split(",", %csv)
					# create the listviewitem object and set it's text values
					%lvi = $new(listviewitem, %lvParent)
					%whatwegot = "Pieces:"
					for (%i = 0; %i < %pieces[]#; %i++)
					{
						if (%i == 2) {%pieces[%i] = $file.fixpath(%pieces[%i]);}
						%lvi->$setText(%i, $unserialize(%pieces[%i]))
						%whatwegot << %i = %pieces[%i]
					}
					if (%G_hush->%debug) debug -c info: %whatwegot
					return %lvi
				}
				else
					if (%G_hush->%debug) debug -c value for lvParent (second parameter) was either not an object, or was no listview object type.
			}
			else
				if (%G_hush->%debug) debug -c value for lvParent (second parameter) was null.	
		}
		else
			if (%G_hush->%debug) debug -c value passed was not a csv string. it was null!
		
		return $false
	}
	
	function dlgMediaLoc(used to select media locations ie: directories/folders)
	{
		# this function allows user to select a directory for the library
		# only parameter for this function is the "location description" which allows to label the location being chosen
		# it will return whatever dialog.file returns. false if user cancels the dialog, otherwise the location chosen.
		
		dialog.file (dir, Select media location,"All files (*.*)")
		{
			if($0 == "")
			{
				if (%G_hush->%debug) debug -c Interesting: no location returned. (user clicked cancel?)
			}
			else
			{
				# location is passed back in $0
				%G_hush->%libraryoptions->%lblMediaPath->$setText($file.fixpath("$0"))
			}
		}
	}
	
	function dlgIncomingLoc(used to select the incoming directory)
	{
		# this function allows user to select a directory for the incoming location
		# only parameter for this function is the "location description" which allows to label the location being chosen
		# it will return whatever dialog.file returns. false if user cancels the dialog, otherwise the location chosen.
		
		dialog.file (dir, Select DCC incoming location,"All files (*.*)")
		{
			if($0 == "")
			{
				if (%G_hush->%debug) debug -c Interesting: no location returned. (user clicked cancel?)
			}
			else
			{
				# location is passed back in $0
				%G_hush->%libraryoptions->%lblIncoming->$setText("Download Directory: <b>$file.fixpath($0)</b>")
				%G_hushOptions{"MediaIncoming"} = $file.fixpath($0)
				option stringIncomingPath $file.fixpath($0)
			}
		}
	}
	
	function constructor()
	{
		# hush::libraryoptions
		# creates widget objects and member values for the hush Library options
		
		
		@%libraryFileTypes = $hash("Movies", "mkv,avi,mp4,mov,flv", "TV Shows", "mkv,avi,mp4,mov,flv", "eBooks", "pdf,txt,rtf,mobi,doc", "MP3", "mp3", "Games", "iso,bin,cue,zip,exe,gz,tar", "Software", "zip,exe,bin,msi")
		
		@%layout = $new(layout, $$)
		
		@$setGeometry(0,0,700,450)
		@$setWindowTitle("Hush::Library::Options")
		@$centerToScreen()
		
		@%layout->$setSpacing(3)
		
		### child widgets for Library Options
		
		# label home msg at top of window
		@%lblHomeMsg = $new(label, $$)
		@%lblHomeMsg->$setText("<b>Download Location</b>")
		#@%lblHomeMsg->$setAlignment(Center)
		
		# label for incoming
		@%lblIncoming = $new(label, $$)
		@%lblIncoming->$setText(Download Directory: <b>$option(stringIncomingPath)</b>)
		@%lblIncoming->$setTooltip("Set the location that files will download to.<br/>Note: This will alter KVIrc's DCC download location <i>stringIncomingPath</i> found in Settings -&gt; Configure KVIrc -&gt; DCC -&gt; File Transfer -> Download folder.")
		
		# button incoming directory select
		@%btnIncoming = $new(button, $$)
		@%btnIncoming->$setText("Select Download Location")
		@%btnIncoming->$setTooltip("Click to select where DCC transfers are downloaded to.<br/>Note: This will alter KVIrc's DCC download location <i>stringIncomingPath</i> found in Settings -&gt; Configure KVIrc -&gt; DCC -&gt; File Transfer -> Download folder.")
		
		@%lblMediaLoc = $new(label, $$)
		@%lblMediaLoc->$setText("<hr/><b>Add New Media Location</b>")
		@%lblMediaLoc->$setTooltip("Add storage locations of your media collections")
		#@%lblMediaLoc->$setAlignment(Center)
		
		# lineedit for name of media entry
		@%leMediaLoc = $new(lineedit, $$)
		@%leMediaLoc->$setTooltip("Enter a unique name for this media location")
		@%leMediaLoc->$setText("Location Name")
		
		# combobox (dropdown) for media types
		@%coboMediaLoc = $new(combobox, $$)
		@%coboMediaLoc->$insertItem("eBooks")
		@%coboMediaLoc->$insertItem("Movies")
		@%coboMediaLoc->$insertItem("Music")
		@%coboMediaLoc->$insertItem("Other")
		@%coboMediaLoc->$insertItem("Software")
		@%coboMediaLoc->$insertItem("TV Shows")
		@%coboMediaLoc->$setTooltip("Select the general media type")
		
		
		# button media type directory select
		@%btnMediaLoc = $new(button, $$)
		@%btnMediaLoc->$setText("Select Location")
		@%btnMediaLoc->$setTooltip("Click to select where this media is located")
		
		# label existing media locations
		@%lblExistingMedia = $new(label, $$)
		@%lblExistingMedia->$setText("<hr/><b>Existing Media Locations</b>")
		
		# listview media types and directory locations
		@%lvMediaLoc = $new(listview, $$)
		@%lvMediaLoc->$setTooltip("Shows your currently set media locations")
		@%lvMediaLoc->$addColumn("Name", $math.floor($(@$width * 0.25)))
		@%lvMediaLoc->$addColumn("Media Type", $math.floor($(@$width * 0.25)))
		@%lvMediaLoc->$addColumn("Location", $math.floor($(@$width * 0.5)))
		@%lvMediaLoc->$setSortingEnabled($true)
		
		# counter value for number of columns in lvMediaLoc's lvis
		@%lviCols = 3
		
		# button media location add to listview
		@%btnMediaAdd = $new(button, $$)
		@%btnMediaAdd->$setText("Add")
		@%btnMediaAdd->$setTooltip("Click to add a new media location entry to the library")
		
		# button scan media library
		@%btnScanMedia = $new(button, $$)
		@%btnScanMedia->$setText("Scan Library")
		@%btnScanMedia->$setTooltip("Click to scan files in media library paths")
		
		# label media locations path
		@%lblMediaPath = $new(label, $$)
		@%lblMediaPath->$setTooltip("Where this media is stored")
		@%lblMediaPath->$setAlignment(Center)
		
		# button media location remove from listview
		@%btnMediaRm = $new(button, $$)
		@%btnMediaRm->$setText("Remove")
		@%btnMediaRm->$setTooltip("Click to remove the higlighted entry from the library")
		
		# label status left
		@%lblStatusLeft = $new(label, $$)
		@%lblStatusLeft->$setTooltip("Status bar area. Look here for messages when operations are carried out.")
		@%lblStatusLeft->$setAlignment(Left)
		
		### POPULATE any child widgets
		
		# Media Library Listview
		# fetch library locations from hush config file into array
		%libLocs = %G_hush->$configLoad(%G_hush->%hushConfig, libraryLocations)
		# loop libLocs array and create listviewitems from the values inside, assign each lvi to lviMediaEntriesArray
		for (%i = 0; %i < %libLocs[]#; %i++)
		{
			%lvi = @$fnCSVtoLVI(%libLocs[%i], @%lvMediaLoc)
			@%lviMediaEntries[%i] = %lvi
		}
		
		#### do LAYOUT
		
		@%layout->$setColumnStretch(0, 10)
		@%layout->$setColumnStretch(2, 10)
		@%layout->$addMultiCellWidget(@%lblHomeMsg, 0,0,0,2)
		@%layout->$addMultiCellWidget(@%lblIncoming, 1,1,0,1)
		@%layout->$addMultiCellWidget(@%btnIncoming, 1,1,2,2)
		@%layout->$addMultiCellWidget(@%lblMediaLoc, 2,2,0,2)
		@%layout->$addMultiCellWidget(@%leMediaLoc, 3,3,0,0)
		@%layout->$addMultiCellWidget(@%coboMediaLoc, 3,3,1,1)
		@%layout->$addMultiCellWidget(@%btnMediaLoc, 3,3,2,2)
		@%layout->$addMultiCellWidget(@%lblMediaPath, 4,4,2,2)
		@%layout->$addMultiCellWidget(@%btnMediaAdd, 5,5,0,1)
		@%layout->$addMultiCellWidget(@%btnScanMedia, 5,5,2,2)
		@%layout->$addMultiCellWidget(@%lblExistingMedia, 6,6,0,2)
		@%layout->$addMultiCellWidget(@%lvMediaLoc, 7,7,0,2)
		@%layout->$addMultiCellWidget(@%btnMediaRm, 8,8,0,2)
		@%layout->$addMultiCellWidget(@%lblStatusLeft, 9,9,0,0)
		
		### CONNECT widgets to functions
		objects.connect @%btnIncoming clicked $$ dlgIncomingLoc
		objects.connect @%btnMediaLoc clicked $$ dlgMediaLoc
		objects.connect @%btnMediaAdd clicked $$ actionMediaAdd
		objects.connect @%btnScanMedia clicked %G_hush->%library scanLibrary
		objects.connect @%lvMediaLoc itemActivated $$ actionMediaEntrySelected
		objects.connect @%btnMediaRm clicked $$ actionMediaRemove
		
		
		### private IMPLS
		
		privateimpl(@%leMediaLoc, mousePressEvent)
		{
			# get rid of the default value
			if (@$text() == "Location Name")
				@$setText("")
		}
		
		privateimpl($$, closeEvent)
		{
			# close event of hush library options window means we should save values to disk
			# if (%G_hush->%debug) debug -c info: closeEvent called, building array of library locations (@%lvMediaLoc->$topLevelItemCount() locations found)
			
			for (%i = 0; %i < @%lvMediaLoc->$topLevelItemCount(); %i++)
				%libLocs[%i] = @$fnLVItoCSV(@%lviMediaEntries[%i])
			
		#	debug -c libLocs[0] = %libLocs[0]
			# if (%G_hush->%debug) debug -c info: calling hush::configSave
			%G_hush->$configSave(@%hushConfig, libraryLocations, %libLocs)
			%G_hush->$configSave(@%hushConfig, options, %G_hushOptions)
			# if (%G_hush->%debug) debug -c info: closing library options widget
		}
	}
	
	function checkExistingMedias(checks if the data for a new media entry is valid or not)
	{
		# $0 = name $1 = type $2 = path
		
		# iterate over the contents of the listview widget and compare the data we have with that from the listview entries.
		
		# check we got our new values to verify...
		if ($0 == "" || $1 == "" || $2 == "")
		{
			if (%G_hush->%debug) debug -c Interesting: no location returned. (user clicked cancel?)
			dialog.message -b (Nope, "At least one of your new media entry's values is missing. This could be a bug, or you just forgot to set one." information, OK) {}
			return $false;
		}
		else
		{
			if ($typeOf(@%lviMediaEntries) == "array")
			{
				# loop through the media entries listviewitem array
				for (%i = 0; %i < @%lviMediaEntries[]#; %i++)
				{
					if (@%lviMediaEntries[%i]->$text(0) == $0 || @%lviMediaEntries[%i]->$text(2) == $2)
					{
						dialog.message -b (Nope, "The media's Name or Location is already found in the Library's entry list.<br/>Check your new entry values and try again.", information, OK) {}
						return $false;
					}
				}
				return $true;
			}
			else
			{
				# if @%lviMediaEntries is not an array, it means we haven't made it yet, so this is the first entry. return true!
				return $true;
			}
		}
	}
	
	function actionMediaRemove(remove an entry from the media library listview)
	{
		# TODO - this code is making kvirc crash when we click on the media location remove button.
		
		%lvi = @%lvMediaLoc->$selectedItems()
		
		# NOTE: %lvi should contain a listviewitem object
		# compare the selected liveviewitem to the ones in the array and remove the one that is a match
		
		if (%lvi != $null)
		{
			if ($typeOf(@%lviMediaEntries) == array)
			{
				# loop through lviMediaEntries array
				for (%i = 0; %i < @%lviMediaEntries[]#; %i++)
				{
					if (%G_hush->%debug) {debug -c lviMediaEntries[%i] text = @%lviMediaEntries[%i]->$text(0) and lvi text = %lvi[0]->$text(0);}
					if (@%lviMediaEntries[%i]->$text(0) == %lvi[0]->$text(0))
					{
						# delete the matching lvi to remove it.
						if (%G_hush->%debug) {debug -c lviMediaEntries[%i] name: '@%lviMediaEntries[%i]->$text(0)' matches selected item's name: '%lvi[0]->$text(0)' so deleting.;}
						delete @%lviMediaEntries[%i]
						@%lviMediaEntries[%i] = $null
						# update the lviMediaEntries array because we just lost an array index position
						%temp = $array();
						foreach (%entry, @%lviMediaEntries)
						{
							if (%entry != $null) 
							{
								%temp <+ %entry;
							}
						}
						@%lviMediaEntries = %temp
						return $true
					}
				}
			}
			else	
				if (%G_hush->%debug) debug -c Nope: lviMediaEntries is not an array. Maybe there's nothing in the listview yet?
		}
		else
			if (%G_hush->%debug) debug -c Nope: lvi returned from lviMediaLoc->\$selectedItems() is not a listviewitem object! (it returned as a null value)
		
		return $false
	}
	
	function actionMediaEntrySelected(handles when a user clicks an existing media entry in the listview widget)
	{
		if (%G_hush->%debug) debug -c we activated an item! values = $0->$text(0) .. $0->$text(1) .. $0->$text(2)
	}
	
	function actionMediaAdd(adds an entry to the media library)
	{
		# put the new media location into the media library hash and the listview widget
		
		# check if we have all the required data
		# check that the new name is unique (doesnt exist in our list already)
		# check that the path doesn't exist in our list already
		
		if ((@%leMediaLoc->$text() != "") && (@%lblMediaPath->$text() != ""))
		{
			# check if any of the unique values match existing entries (name and path must be unique)
			if (@$checkExistingMedias(@%leMediaLoc->$text(), @%coboMediaLoc->$current(), @%lblMediaPath->$text()) == $true)
			{
				if ($typeOf(@%lviMediaEntries) == array)
					%i = @%lviMediaEntries[]#
				else
					%i = 0;
				# put values into listview
				@%lviMediaEntries[%i] = $new(listviewitem, @%lvMediaLoc)
				@%lviMediaEntries[%i]->$setText(0, @%leMediaLoc->$text())
				@%lviMediaEntries[%i]->$setText(1, @%coboMediaLoc->$current())
				@%lviMediaEntries[%i]->$setText(2, @%lblMediaPath->$text())
				# reset the name and path to null
				if (%G_hush->%debug) debug -c info: New Media Entry: Index: %i | Name = @%leMediaLoc->$text() | Type = @%coboMediaLoc->$current() | Path = @%lblMediaPath->$text()
				@%leMediaLoc->$setText("")
				@%lblMediaPath->$setText("")
			}
			else
			{
				if (%G_hush->%debug) debug -c New Media Entry details match an existing entry so ignoring. 
			}
		}
		else
			dialog.message -b (Nope, "You need to set both the Name and the Location for the media entry.<br/>", information, OK) {}
	}
	
}

class("hush::library","object")
{
	function scanLibrary()
	{
		# this function will scan a path or array of paths for media items
		
		/* 
		dev note to self because you dont work on this often enough because you work too much in 2017 & 2018: 
		once you have made the hush::libraryoptions object, displayed it on screen and added a media library entry
		you will then find the media entry details in %G_hush->%libraryoptions->%lviMediaEntries[] which is an array
		that holds listviewitem objects (lvi)
		
		each lvi contains the columns: 
		 0 - media location name
		 1 - media type
		 2 - media path
		
		in this scanLibrary function we want to access the media path and see what is stored in it
		you can fetch the values from the array using: %G_hush->%libraryoptions->lviMediaEntries[n]->$text(c)
		where n is the index value and c is the lvi column number
		*/
		
		# get local file info from storage paths
		# iterate over the lviMediaEntries array
		if (%G_hush->%libraryoptions->%lviMediaEntries[]# != 0)
		{
			# wipe the old media library array
			@%arr_Library = $array
			@%arr_Movies = $array
			@%arr_TVShows = $array
			@%moviesPermRecord  = %G_hush->$configLoad(@%hushMoviesPermRecord, moviesPermRecord)
			# update the status message on the library options widget
			%G_hush->%libraryoptions->%lblStatusLeft->$setText("Scanning media locations...")
			for (%i = 0; %i < %G_hush->%libraryoptions->%lviMediaEntries[]#; %i++)
			{
				# check if path exists
				%path = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2)
				if (!$file.exists(%path))
				{
					# path does not exist
					if (%G_hush->%debug) {debug -c info - file_exists returned false for path: %path;}
				}
				else
				{
					# path does exist so lets scan to see what's in it
					# fnScanDirs is recursive and scans subdirectories
					if (%G_hush->%debug) {debug -c info - file_exists returned true for path: %path;}
					%filetypes = %G_hush->%libraryoptions->%libraryFileTypes{%G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1)}
					if (%G_hush->%debug) {debug -c info - looking for filetypes: %filetypes;}
					%path = $file.fixpath(%path)
					@%arr_Library <+ @$fnScanDirs(%path, %filetypes)
				}
			}
			if (%G_hush->%debug) {debug -c Library Scan Complete. @%arr_Library[]# entries in library array;}
			# scan finished, update status message on library options widget
			%G_hush->%libraryoptions->%lblStatusLeft->$setText("Scan complete. %G_hush->%libraryoptions->%lviMediaEntries[]# locations scanned. @%arr_Library[]# items found.")
			# write the hush media library to file on disk
			file.remove -q @%hushLibrary
			%G_hush->$configSave(@%hushLibrary,library,@%arr_Library)
			# try to find what TV shows we have
			@$buildTVShows()
			# try to find what Movies we have
			@$buildMovies()
			# write the TVShows array to file on disk
			file.remove -q @%hushTVShows
			%G_hush->$configSave(@%hushTVShows,tvshowTitles,@%arr_TVShows)
			# write the Movies array to file on disk
			file.remove -q @%hushMovies
			%G_hush->$configSave(@%hushMovies,movieTitles,@%arr_Movies)
			# write the Movies permanent record to disk
			%G_hush->$configSave(@%hushMoviesPermRecord,moviesPermRecord,@%moviesPermRecord)
		}
		else
		{
			# probs should use a dialog to output a message to user here
			dialog.message -b (Hush Media Scan - Information, "There are no media locations set.<br/>Add at least one media location, then press the scan button.", information, "OK")
			if (%G_hush->%debug) {debug -c hush::libraryoptions::lviMediaEntries object is not set so we can't scan the library. Try setting some media locations in the media library options widget.;}
		}
		
		# dev debug - tell us what the movies array and permanent record hold after the scan is done
		
		#debug -c $k(4)movie array length: @%arr_Movies[]#$k()
		#debug -c $k(4)movies permanent record length: @%moviesPermRecord[]#$k()
		
		# sort data? - better if data is sorted in the database then searching is faster later on
	}
	
	function fnScanFiles($0 = path to scan, $1 csv filetypes)
	{
		# this function scans a path for files and recurses into fnScanDirs if folders are found.
		
		%path = $0
		%filetypes = $1
		%fts = $str.split(",", %filetypes)
		%contents = $file.ls(%path, dfrwxnz)
		
		# loop through file listing of current directory
		for (%i = 0; %i < %contents[]#; %i++)
		{
			%match = $false
			%item = %path/%contents[%i]
			# ignore . and ..
			if (%contents[%i] != "." && %contents[%i] != "..") 
			{
				#if (%G_hush->%debug) { echo -d %fn - %item }
				# if item is a directory
				if ($file.type(%item) == d)
				{
					if (%G_hush->%debug0) {debug -c %contents[%i] is a directory;}
					%resultArray <+ @$fnScanFiles(%item, %filetypes)
				}
				else
				{
					# checks if the item ends in a known good wanted filetype, sets match to true if it does
					for (%n = 0; %n <= %fts[]#; %n++)
					{
						if ($str.right(%item, $str.length(%fts[%n])) == %fts[%n] && %fts[%n] != $null)
						{
							%match = $true;
						}
					}
					if (%match == $true)
					{
						# item is not a directory, so must be a file, add it to result array
		### dev debug mostly				if (%G_hush->%debug) {debug -c Filetype Match: %item;}
						%resultArray <+ %item
					}
					# else filetype of item is not in filetypes
				}
			}
		}
		
		return %resultArray
	}
	
	function fnScanDirs($0 = path to scan, $1 - csv filetypes)
	{
		# this function will scan a path for folders. if a folder is found, it will call fnScanFiles to retrieve the 
		# files in the folder, and then recurse into itself if sub-folders are found.
		
		# $1 - csv filetypes is a comma seperated string of the types we should look for
		
		%path = $0
		%filetypes = $1
		%fts = $str.split(",", %filetypes)
		%contents = $file.ls(%path, dfrwxnz)
		
		# iterate through directory listing
		for (%i = 0; %i < %contents[]#; %i++)
		{
			%match = $false
			%item = %path/%contents[%i]
			# ignore . and ..
			if (%contents[%i] != "." && %contents[%i] != "..") 
			{
				#if (%G_hush->%debug) { echo -d %item }
				# if item is a directory, scan for files in it
				if ($file.type(%item) == d)
				{
					if (%G_hush->%debug0) {debug -c %contents[%i] is a directory;}
					%resultArray <+ @$fnScanFiles(%item, %filetypes)
				}
				else
				{
					# checks if the item ends in a known good wanted filetype, sets match to true if it does
					for (%n = 0; %n <= %fts[]#; %n++)
					{
						if ($str.right(%item, $str.length(%fts[%n])) == %fts[%n] && %fts[%n] != $null)
						{
							%match = $true;
						}
					}
					if (%match == $true)
					{
						# item is a file not a directory, so add it to the result array
		### dev debug mostly				if (%G_hush->%debug) debug -c Filetype Match: %item
						%resultArray <+ %item
					}
					# else filetype of item is not in filetypes
				}
			}
		}
		
		return %resultArray
	}
	
	function fnFindLatest(this function tries to find the latest item in a collection)
	{
		# this function will try to find the "Latest" item in a collection of items.
		
		/* the aim is to make this function as universal as possible, that is why it is finding the 'latest' thing
		in a 'collection' of things. hopefully it will work for movies, tv shows, music, software etc.
		
		Collection - a collection is simply a group of things. This could be files or folders, it doesn't matter
		Latest - how do we define something as being the 'latest' thing? we can use multiple elements with an order 
		of precedence to decide this.
		 1. Analyze the Collection and find Alike Element:
			Eg: The path to a TV Show might be: D:\TV\Show Name\Season NN\ - The Alike Element for the TV Show Seasons
			in this collection would be "D:\TV\Show Name\Season " and the NN is the Unique Element that we use to
			deicde which item is the Latest.
		 2. Compare the Unique Elements against a database source to determine how much of a Collection the user
			has.
			We will need access to an online database for each media type to do this effectively.
		 3. Determine what content the user wants to grab next
			Should we start from:
			 - the earliest missing item in the user's collection
			 - the latest missing item in the user's collection
			 - the latest item in the online database
		
		The above outline probably won't (and shouldn't) all exist in this function but be handled by a number of
		functions.
		
		Useful info:
		
		We have the user set their media library locations, so we know what type of media to expect at a base path.
		
		%G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1) will get the media type
		%G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2) will get the base path
		*/
	}
	
	function constructor()
	{
		@%hushLibrary = $file.localdir("config/Hush/library.txt")
		@%hushMovies  = $file.localdir("config/Hush/movies.txt")
		@%hushTVShows = $file.localdir("config/Hush/tvshows.txt")
		@%hushMoviesPermRecord = $file.localdir("config/Hush/moviesPermRecord.txt")
		@%arr_Library = %G_hush->$configLoad(@%hushLibrary, library)
		@%arr_Movies  = %G_hush->$configLoad(@%hushMovies, movieTitles)
		@%arr_TVShows = %G_hush->$configLoad(@%hushTVShows, tvshowTitles)
		@%moviesPermRecord  = %G_hush->$configLoad(@%hushMoviesPermRecord, moviesPermRecord)
		
		/*
		
		arr_Movies / %G_hush->%library->%arr_Movies
			An array that holds movie titles that currently exist on disk storage in the Hush Media Library paths.
			Note that the titles in this array have dot spacing like: 
			Movie.Title.1998
		
		moviesPermRecord / %G_hush->%library->%moviesPermRecord
			An array that holds movie titles that are in Hush's permanent record. This array is used to ensure that we don't
			automatically redownload movies that we have had before.
			Note that the titles in this array have whitespace spacing and bracketed years like: 
			Movie Title (1998)
		*/
	}
	
	function buildTVShows(this function looks at the library and determines what TV Show titles the user already has in the their Library)
	{
		/*
		 This function analyzes the Hush Media Library and looks for Movie media locations.
		 It looks at the contents of TV Show type media locations and will try to get the names of TV shows in
		 that location.
		
		 Relevant variables for this function are:
		
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(0) will get the media entry name
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1) will get the media type
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2) will get the base path
		
		 %G_hush->%arr_Library	is the full hush media library array
		
		 @%arr_TVShows			is the array populated with TV Show names
		 @%tvFoundAlready		is a CSV string holding all the TV Names this function has already found. Easily
							searched using $str.contains. This is a member variable so it is preserved in 
							memory. This means subsequent media searches wont add duplicates to the TVShow 
							array.
		
		Probably TODO: 
		 Add a parameter to clear the existing TVShow array and repopulate it as the code currently always
		 just appends to the TV Show array
		 Advanced repopulation - compare a newly repopulated tv array to the old one and find differences,
		 preserve those differences if we want to. (We might add "Add a TV Show manually" feature later and this 
		 would preserve those manually added entries)
		
		*/
		
		%success = $false;
		# loop through the media library location entries the user has supplied
		for (%i = 0; %i < %G_hush->%libraryoptions->%lviMediaEntries[]#; %i++)
		{
			# first check that the item in the array is a listviewitem
			if (%G_hush->%libraryoptions->%lviMediaEntries[%i]->$className() == listviewitem)
			{
				%medianame = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(0)
				%mediatype = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1)
				%basepath = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2)
				# check that the media entry is a TV Show type
				if (%mediatype == "TV Shows")
				{
					%success = $true;
					%tCount = 0;
					if (%G_hush->%debug) debug -c info: $k(10)'%medianame' is media type '%mediaType'$k()
					# now run through the media library and find all entries with this media entry's base path and get the RHS of their paths
					for (%n = 0; %n < @%arr_Library[]#; %n++)
					{
						# check that the string from the array contains the base path from the current lvi
						if ($str.contains(@%arr_Library[%n], %basepath))
						{
							%tvName = @%arr_Library[%n]
							# remove tv base path from database entry
							%tvName = $str.replace(%tvName,%basepath/,"")
							# remove errthing after the supposed tv name
							%tvName =~ s/\/.*//gi
							# check if supposed TV Name has already been found add it to result array if its new
							if (!$str.contains(@%tvFoundAlready, %tvName))
							{
								# add tvName to tvFoundAlready
								@%tvFoundAlready <, %tvName
								@%arr_TVShows <+ %tvName
								%tCount++;
		### dev debug mostly		if (%G_hush->%debug) debug -c info: adding alleged TV Show to tv array: %tvName
							}
						}
					}
					if (%G_hush->%debug) debug -c info: $k(10)found %tCount TV show titles within the @%arr_Library[]# entries in Hush Media Library$k()
				}
				else
				{
		# dev debug			if (%G_hush->%debug) debug -c info: %medianame is type %mediatype, ie: not TV Shows, so ignoring
				}
			}
			else
			{
				if (%G_hush->%debug) debug -c Nope: libraryoptions->lviMediaEnrtries[%i] object class is not a listviewitem as expected.
			}
		}
		if (%success)
		{
			# return the number of items found to show success
			$sort(@%arrTVShows)
			return @%arr_TVShows[]#
		}
		if (%G_hush->%debug && %G_hush->%libraryoptions->%lviMediaEntries[]# == 0) debug -c Nope: no media library entries were found
		return $false
	}
	
	function buildTVSeasons()
	{
		/* this function needs to look at the TV Shows array and ascertain which seasons for which shows we have
		
		@%arr_LibraryTVShows 	<- holds the TV Show Names
		@%arr_Library			<- holds the full media library (full paths to individual filenames)
		
		this function needs to:
		 1. traverse @%arr_Library checking the entries against the tv show names
		 2. check an entry for a Season value
		 3. if the season value for that tv show name is new, add it to seasons
		
		*/
		
		# find which media enries are TV Show media type
		%arrMTI = %G_hush->%libraryoptions->$getMediaTypeIndexs("TV Shows")
		# alias for lviMediaEntries (easier to read)
		%lvi = %G_hush->%libraryoptions->%lviMediaEntries
		
		# loop through media library
		for (%i = 0; %i < @%arr_Library[]#; %i++)
		{
			
			# loop through arrMTI
			foreach (%mtIndex, %arrMTI)
			{
				# ugh. do something
				return
			}
		}
	}
	
	function buildMovies(this function looks at the Library and determines what Movie titles the user has in their Library)
	{
		/*
		 This function analyzes the Hush Media Library and looks for Movie media locations.
		 It looks at the contents of Movie media locations and will try to get the names of Movies in
		 those locations.
		
		 Relevant variables for this function are:
		
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(0) will get the media entry name
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1) will get the media type
		 %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2) will get the base path
		
		 @%arr_Library			is the full hush media library array
		
		 @%arr_LibraryMovies	is the array this function will populate
		 @%moviesFoundAlready	is a CSV string holding all the Movie titles this function has already found. Easily
							searched using $str.contains. This is a member variable so it is preserved in 
							memory. This means subsequent media searches wont add duplicates to the Movies 
							array.
		*/
		
		%success = $false;
		if (%G_hush->%libraryoptions->%lviMediaEntries[]# < 1)
		{
			if (%G_hush->%debug) {debug -c There are no media source locations in library options.;} 
			return $false;
		}
		# loop through the media library location entries the user has supplied
		for (%i = 0; %i < %G_hush->%libraryoptions->%lviMediaEntries[]#; %i++)
		{
			# first check that the item in the array is a listviewitem
			if (%G_hush->%libraryoptions->%lviMediaEntries[%i]->$className() == listviewitem)
			{
				%medianame = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(0)
				%mediatype = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(1)
				%basepath = %G_hush->%libraryoptions->%lviMediaEntries[%i]->$text(2)
				# check that the media entry is Movies type
				if (%mediatype == "Movies")
				{
					%tCount = 0;
					%success = $true;
					if (%G_hush->%debug) debug -c info: $k(12)'%medianame' is media type '%mediatype'$k()
					# now run through the media library and find all entries with this media entry's base path and get the RHS of their paths
					for (%n = 0; %n < @%arr_Library[]#; %n++)
					{
						# check that the string from the array contains the base path from the current lvi
						if ($str.contains(@%arr_Library[%n], %basepath))
						{
							%movieName = @%arr_Library[%n]
							# remove movie base path from library entry
							%movieName = $str.replace(%movieName,"%basepath/","")
							%garbage = %movieName
							# next line removes the movie name, leaving us the garbage
							%garbage =~ s/.*\.([0-9]{4})\.//mi
							%garbage = %G_hush->%common->$fnStringEscapeForRegex(%garbage)
							# now remove the garbage from %movieName
							%movieName =~ s/\.%garbage//i
							# check if supposed Movie name has already been found add it to result array if it's new
							if (!$str.contains(@%moviesFoundAlready, %movieName))
							{
								# add movieName to movieFoundAlready
								@%moviesFoundAlready <, %movieName
								@%arr_Movies <+ %movieName
								%tCount++;
		### dev debug mostly		if (%G_hush->%debug) debug -c info: adding alleged Movie title to Movie array: %movieName
								%movieName = $str.replace(%movieName,.," ")
								%movieYear = $str.rightfromlast(%movieName," ")
								%movieName = $str.lefttolast(%movieName," ");
								%movieYear = $str.replace(%movieYear,"(","")
								%movieYear = $str.replace(%movieYear,")","")
								if ($str.isUnsignedNumber(%movieYear))
								{
									# if movie title string is not found in moviesPermRecord array
									if (!$str.contains(@%moviesPermRecord,"%movieName (%movieYear)"))
									{
										# add title to moviesPermRecord array
										@%moviesPermRecord <+ "%movieName (%movieYear)"
									}
								}
								else
								{
									if (%G_hush->%debug) {debug -c movieYear doesn't look like a year number. we found: %movieYear in title: %movieName;}
								}
							}
						}
					}
					if (%G_hush->%debug) debug -c info: $k(12)found %tCount movie titles within @%arr_Library[]# entries in Hush Media Library$k()
				}
				else
				{
		# dev debug			if (%G_hush->%debug) debug -c info: %medianame is type %mediatype, ie: not Movies, so ignoring
				}
			}
			else
			{
				if (%G_hush->%debug) debug -c Nope: libraryoptions->lviMediaEnrtries[%i] object class is not a listviewitem as expected.
			}
		}
		if (%success)
		{
			# return the number of items found to show success
			@%arr_Movies = $sort(@%arr_Movies)
			@%moviesPermRecord = $sort(@%moviesPermRecord)
			return @%arr_Movies[]#
		}
		if (%G_hush->%debug && %G_hush->%libraryoptions->%lviMediaEntries[]# == 0) debug -c Nope: no media library entries were found
		return $false
	}
	
}

class("hush::instantsearch","widget")
{
	function fnUpdateTotalRows(updates the UI label to show how many rows are in the database)
	{
		# update the total number of records in the database for UI info
		%query = "SELECT COUNT(packName) as totalRows FROM instant;"
		%G_hush->%sql->$queryPrepare(%query)
		if (!%G_hush->%sql->$queryExec(%query))
		{
			if (%G_hush->%debug)
				debug -c $k(5)SQL SELECT query failed. Error given: $b()%G_hush->%sql->$lastError($true)$b()$k() (You should probably try restarting KVIrc to fix this, if that doesn't work delete the sqlite database file and restart KVIrc);
		}
		else
		{
			%G_hush->%sql->$queryFirst()
			%row = %G_hush->%sql->$queryRecord()
			@%lblIStotalRows->$setText("Total records in database: %row{"totalRows"}")
		#	debug -c totalRows: %row{"totalRows"}
		}
	}
	
	function fnLaunchSearch(this function accepts search term supporting wildcards * and ? and fetches matching results from the hush instant search database. $0 = search term)
	{
		# this function will execute when the user presses the LAUNCH button
		
		# reset the lvi results array because we're doing a new search
		if ($typeOf(@%arrayLviISResults) == array)
			for (%i = 0; %i < @%arrayLviISResults[]#; %i++)
				if ($typeOf(@%arrayLviISResults[%i]) == hobject)
					delete @%arrayLviISResults[%i];
		@%arrayLviISResults = $array;
		
		%q = $0
		# create SQL query from leIS, swap wildcard characters for SQL
		%q = $str.replace(%q, "*", "%")
		%q = $str.replace(%q, " ", "%")
		%q = $str.replace(%q, "?", "_")
		
		# set query syntax for search exceptions to be obeyed
		%searchExceptions = "";
		
		if (%G_hushOptions{"ISObeySE"})
		{
			for (%i = 0; %i < %G_hushSExceptions[]#; %i++)
			{
				%sx = %G_hushSExceptions[%i]
				%sx = $str.replace(%sx, "*", "%")
				%sx = $str.replace(%sx, " ", "%")
				%sx = $str.replace(%sx, "?", "_")
				%searchExceptions .= " AND packName NOT LIKE '\%%sx\%'";
			}
		}
		
		%query = "SELECT strftime('\%Y\%m\%d-\%H:\%M', DATETIME(timestamp, 'unixepoch', 'localtime')) AS timestamp,networkName,channelName,botName,packName,(substr('00000'||(packSize / 1024 / 1024), -5, 5)||' Mb') AS packSize,packNum,substr('000'||packGets, -3, 3) AS packGets FROM instant WHERE timestamp IN (SELECT MAX(timestamp) FROM instant GROUP BY botName,packName,packSize) AND packName LIKE '\%%q\%'%searchExceptions ORDER BY packName,timestamp;"
		#%query = "SELECT strftime('\%Y\%m\%d-\%H:\%M', DATETIME(timestamp, 'unixepoch', 'localtime')) AS timestamp,networkName,channelName,botName,packName,(substr('00000'||(packSize / 1024 / 1024), -5, 5)||' Mb') AS packSize,packNum,substr('000'||packGets, -3, 3) AS packGets FROM instant WHERE timestamp IN (SELECT MAX(timestamp) FROM instant GROUP BY botName,packName,packSize) AND packName MATCH '%q'%searchExceptions ORDER BY packName,timestamp;"
		#if (%G_hush->%debug) {debug -c query = %query;}
		
		%colPos = $hash(timestamp, 0, networkName, 1, channelName, 2, botName, 3, packName, 4, packSize, 5, packNum, 6, packGets, 7)
		
		# check if sql connection exists, make it if it doesnt, halt if it fails.
		if (%G_hush->%sql->$className != sql)
			if (!%G_hush->$dbConnect())
				halt;
		
		# fetch results from database
		%G_hush->%sql->$queryPrepare(%query)
		if (%G_hush->%sql->$queryExec(%query))
		{
			# set to first result in the set
			%G_hush->%sql->$queryFirst();
			# loop through result set and build array
			%i = 0
			do {
				%row = %G_hush->%sql->$queryRecord();	
				if (%row{"packName"})
				{
					# %row now contains a hash for the current result
					@%arrayLviISResults[%i] = $new(listviewitem, @%lvIS, "Instant Search listviewitem index: %0");
					foreach (%fieldName, $keys(%row))
						@%arrayLviISResults[%i]->$setText(%colPos{"%fieldName"}, %row{"%fieldName"});
					%i++;
				}
			}
			while (%G_hush->%sql->$queryNext());
			# now loop through result array and 
		#	if (%G_hush->%debug) debug -c created %i result entries for instant search;
			@%lblISfoundRows->$setText(%i matches)
			# flash the search exception notice in the status bar in bold if IS is obeying SE
			if (%i == 0 && %G_hushOptions{"ISObeySE"}) 
			{
				%G_hushLive{"ilabelFlash"} = 1
				beep 
				timer(labelFlash, 125)
				{
					%maxCount = 8;
					%suf .= "<"
					%G_hush->%instantsearch->%lblISSEStatus->$setText(%G_hush->%instantsearch->%lblISSEStatus->$text %suf)
					%G_hushLive{"ilabelFlash"}++;
					if (%G_hushLive{"ilabelFlash"} == %maxCount)
					{
						killtimer -q labelFlash
						%G_hush->%instantsearch->%lblISSEStatus->$setText(Search Exceptions are being obeyed)
					}
				}
			}
		# unsure if i like the focus moving from the lineedit query box
		#	# search launched well so give focus to the listview area for keyboard control
		#	@%lvIS->$setFocus();
			return $true;
		}
		else
		{
			if (%G_hush->%debug) debug -c info: queryExec() returned false, so returning false, error given: %G_hush->%sql->$lastError($true);
			return $false;
		}
	}
	
	function constructor(runs on object creation)
	{
		# constructor for hush::instantSearch widget
		
		# use a hash to give the column names a user friendly name, set col widths 
		%ufColNames = $hash(timestamp, "Age", networkName, "Network", channelName, "Channel", botName, "Bot", packName, "Pack Name", packSize, "Size", packNum, "Pack #", packGets, "Grabs")
		%ufColWidths = $hash(timestamp, "150", networkName, "120", channelName, "120", botname, "200", packName, "450", packSize, "100", packNum, "100", packGets, "100")
		
		@%layout = $new(layout, $$)
		@%layout->$setSpacing(3)
		
		@$setGeometry(0,0,1400,600)
		@$setWindowTitle("Hush::Instant Search")
		@$centerToScreen()
		@$setFocus()
		
		### init child widgets for instantSearch
		
		# label for title
		@%lblTitle = $new(label, $$)
		@%lblTitle->$setText("<b>Instant Search</b>")
		@%lblTitle->$settooltip("Search for packs and get instant results without transmitting to the IRC server(s).")
		@%lblTitle->$setAlignment(Left)
		# label for lineedit (so user knows what the line edit is for)
		@%lblIS = $new(label, $$)
		@%lblIS->$setText("Search for: ")
		# lineedit for found content window name
		@%leIS = $new(lineedit, $$, "Instant Search lineedit")
		@%leIS->$setToolTip("Type in here what to search for...<br/>Wildcards are accepted: * for any number of characters<br/>? for single character")
		@%leIS->$setMinimumWidth(350)
		# button to run search
		@%btnISLaunch = $new(button, $$, "Instant Search LAUNCH button")
		@%btnISLaunch->$setText("LAUNCH")
		@%btnISLaunch->$setTooltip("Runs the search.")
		#listview to display results
		@%lvIS = $new(listview, $$, "Instant Search listview")
		@%lvIS->$setToolTip("Search results will be shown here.")
		@%lvIS->$setAllColumnsShowFocus($true)
		@%lvIS->$setSortingEnabled($true)
		# populate listview columns, pull the column names from the database and put them into an array
		if (%G_hush->%sql->$className != sql)
			if (!%G_hush->$dbConnect())
				halt;
		%colNames = %G_hush->%common->$fnDBColsToArray(%G_hush->%sql, instant)
		for (%i = 0; %i < %colNames[]#; %i++)
			@%lvIS->$addColumn("%ufColNames{"%colNames[%i]"}", %ufColWidths{"%colNames[%i]"})
		# checkbox to use SSL DCC
		@%chbISSSLDCC = $new(checkbox, $$, "Instant Search SSLDCC Checkbox")
		@%chbISSSLDCC->$setText(SSLDCC)
		@%chbISSSLDCC->$setToolTip("Toggles if the request will use SSLDCC or not.<br/>Only some channels support SSLDCC!")
		# button for getting a selected pack
		@%btnISGet = $new(button, $$, "Instant Search Get button")
		@%btnISGet->$setText("Request Pack")
		@%btnISGet->$setToolTip("After selecting a pack in the result list, press this to request the pack.")
		
		### seperate widget for status bar area
		@%wgtStatusBar = $new(widget, $$, "Instant Search Status Bar base widget")
		
		# status area labels
		@%lblIStotalRows = $new(label, @%wgtStatusBar, "Instant Search Label for Num of Records in iDB");
		@$fnUpdateTotalRows()
		@%lblISSEStatus = $new(label, @%wgtStatusBar, "Instant Search Label for Search Exception Obey status");
		if (%G_hushOptions{"ISObeySE"}) {@%lblISSEStatus->$setText("Search Exceptions are being obeyed");}
		@%lblISSEStatus->$setAlignment(Right, VCenter)
		@%lblISfoundRows = $new(label, @%wgtStatusBar, "Instant Search Label for Rows Found by Search");
		@%lblISfoundRows->$setAlignment(Right)
		
		@%l1 = $new(layout, @%wgtStatusBar)
		@%l1->$setMargin(0)
		@%l1->$setColumnStretch(0,1)
		@%l1->$setColumnStretch(1,2)
		@%l1->$setColumnStretch(2,0)
		@%l1->$addMultiCellWidget(@%lblIStotalRows, 0,0,0,0)
		@%l1->$addMultiCellWidget(@%lblISSEStatus, 0,0,1,1)
		@%l1->$addMultiCellWidget(@%lblISfoundRows, 0,0,2,2)
		### end status bar area
		
		@%layout->$addMultiCellWidget(@%lblTitle, 0,0,0,2)
		@%layout->$addMultiCellWidget(@%lblIS, 1,1,0,0)
		@%layout->$addMultiCellWidget(@%leIS, 1,1,1,1)
		@%layout->$addMultiCellWidget(@%btnISLaunch, 1,1,2,2)
		@%layout->$addMultiCellWidget(@%lvIS, 2,2,0,2)
		@%layout->$addMultiCellWidget(@%chbISSSLDCC, 3,3,0,0)
		@%layout->$addMultiCellWidget(@%btnISGet, 3,3,1,2)
		@%layout->$addMultiCellWidget(@%wgtStatusBar, 4,4,0,2)
		
		@%layout->$setAlignment(@%chbISSSLDCC, center)
		@%lblISfoundRows->$setMinimumWidth(150)
		
		### privateimpls
		
		# instant search LAUNCH button
		privateimpl(@%btnISLaunch, mousePressEvent)
		{
			# check if text in %leIS exists
			if (@$parent->%leIS->$text() != "")
			{
				# launch the search
				if (@$parent->$fnLaunchSearch(@$parent->%leIS->$text()))
					return $true;
			}
		return $false
		}
		
		# request pack button clicked
		privateimpl (@%btnISGet, mousePressEvent)
		{
			# get selected lvi from lv
			%lvi = @$parent->%lvIS->$selectedItems()
			if (%lvi == $null) {return;}
			# get pack details from lvi
			%colPos = $hash(timestamp, 0, networkName, 1, channelName, 2, botName, 3, packName, 4, packSize, 5, packNum, 6, packGets, 7)
			%pack = %G_hush->%common->$fnLVItoHash(%lvi[0], %colPos)
			# modify networkName to be the irccontext number
			# get irc context list
			foreach (%ic, $context.list)
			{
				if ($context.NetworkName(%ic) == %pack{"networkName"})
				{
					%context = %ic;
					break;
				}
			}
			# call xdcc::hilightsClick alias
		# $0 = ircContext, $1 = hilight window name, $2 = %sendStyle, $3 = %nick, $4 = packName, $5 = packNum
		# $6 = packGets, $7 = packSize
			%sendStyle = SEND;
			if (@$parent->%chbISSSLDCC->$isChecked())
				%sendStyle = SSEND;
		
			%G_hushDownloadHash{"@$parent->%leIS->$text()"}[$length(%G_hushDownloadHash{"@$parent->%leIS->$text()"})] = $new(hush::xdccobject,0,$null,%pack{"networkName"},%pack{"channelName"},%pack{"botName"},%pack{"packName"},%pack{"packNum"},%pack{"packGets"},%pack{"packSize"},Queued,@$parent->%leIS->$text(),%sendStyle,$false)
			%G_hush->%queueeditor->$refreshQueue()
			%packSize = $($int($str.chop(%pack{"packSize"},3)) * 1048576)
			xdcc::hilightsClick %context "%G_hushOptions{"FCW"}" %sendStyle %pack{"botName"} %pack{"packName"} %pack{"packNum"} %pack{"packGets"} %packSize @$parent->%leIS->$text() $($length(%G_hushDownloadHash{"@$parent->%leIS->$text()"}) - 1)
		}
		
		# enter key pressed for lineedit leIS
		privateimpl(@%leIS, keyPressEvent)
		{
		  if ($0 == "Return")
		    @$emit("enterPressed")
		}
		
		# connect %leIS enterPressed to %btnISLaunch mousePressEvent
		objects.connect @%leIS enterPressed @%btnISLaunch mousePressEvent
		
		privateimpl($$, closeEvent)
		{
			$$->$hide();
		}
		
		privateimpl($$, keyPressEvent)
		{
		  if ($0 == "Esc")
		    @$emit("escapePressed")
		}
		
		# connect @%lbS deletePressed to @%btnSRm mousePressEvent
		objects.connect $$ escapePressed $$ closeEvent
	}
	
}

class("hush::common","object")
{
	function fnStringEscapeForRegex(escapes special chars for use in a regex)
	{
		%success = $false
		if (!$isEmpty($0)) {%str = $0;}
		
		if (%str)
		{
			%sChars = $array("[", "]", "{", "}", "(", ")", "+")
			for (%i = 0; %i < %sChars[]#; %i++)
			{
				%chr = %sChars[%i]
				%regexLeft = $str.printf(\\?s,%chr)
				%regexRight = $str.printf(\\\?s,%chr)
				%str =~ s/%regexLeft/%regexRight/gi
			}
			%success = %str
		}
		
		return %success
	}
	
	function fnLVItoHash(convert a listviewitem object to hash, $0 - listviewitem $1 - hash: column structure)
	{
		# convert listviewitem to hash amd return
		
		%lvi = $0
		%colPos = $1
		foreach(%colName, $keys(%colPos))
			%r{"%colName"} = %lvi->$text(%colPos{"%colName"})
		return %r;
	}
	
	function fnDBColsToArray(pulls column names from a database table and returns them as a hash. $0 - database connection, $1 - tableName)
	{
		# this function expects a sql connection object to be passed to it. do that in the calling functions
		# it also expects to have a tablename passed to it
		
		# this function will return the column names from a sqlite database table for you in an array
		%sql = $0
		%table = $1
		
		%query = "PRAGMA table_info ('%table');"
		%sql->$queryPrepare(%query)
		
		if (%sql->$queryExec(%query))
		{
			# set the first result in the array
			%i = 0
			%sql->$queryFirst();
			%names[%i] = %sql->$queryRecord(){"name"}
			# loop through result set and build array
			while (%sql->$queryNext())
			{
				%i++
				%names[%i] = %sql->$queryRecord(){"name"}
			}
			return %names;
		}
		else
		{
			if (%G_hush->%debug) {debug -c info: queryExec() returned false, so returning false, error given: %sql->$lastError();}
			return $false;
		}
	}
	
	function fnCSVtoArray(convert a CSV string to an array)
	{
		# convert a serialized CSV string to an array and return it
		
		%a = $str.split(",", $0)
		for (%i = 0; %i < %a[]#; %i++)
		{
			%a[%i] = $unserialize(%a[%i])
		}
		return %a
	}
	
	function fnArrayRemoveEmptyValues(takes an array and removes the indices with empty values)
	{
		/* this function will remove empty values and their indices from an array
		
		$0 - array: array1
		*/
		
		%success = $false
		if ($typeOf($0) == array) {%arr1 = $0;}
		%n = 0
		
		for (%i = 0; %i < %arr1[]#; %i++)
		{
			if (%arr1[%i] != $null)
			{
				%temp[%n] = %arr1[%i]
				%n++
			}
		}
		%success = %temp
		
		return %success
	}
	
	function fnArrayMerge(this function will merge two arrays together)
	{
		/* this function will merge two arrays together
		
		   By default the function will append the first argument with the second argument.
		   If the third argument is $true it will remove any empty values from the merged array
		   If the fourth argument is $true it will merge the arrays so all the values are unique (no duplicate values)
		   If the fifth argument is $true it will sort the values alphabetically while merging
		
		$fnArrayMerge(array1:array, array2:array, clearEmpty:boolean, unique:boolean, sortMerg:boolean)
		
		$0 - array: array1
		$1 - array: array2
		$2 - boolean: clearEmpty - set to true if you want to remove empty index values from the resulting array
		$3 - boolean: unique - set to true if you want no duplicate values in the resulting array
		$4 - boolean: sortMerge - set to true if you want the values of the merged result array to be sorted alphabetically
		*/
		
		%success = $false
		if ($typeOf($0) == array) {%arr1 = $0;}
		if ($typeOf($1) == array) {%arr2 = $1;}
		if ($typeOf($2) == boolean) {%clearEmpty = $2;}
		if ($typeOf($3) == boolean) {%unique = $3;}
		if ($typeOf($4) == boolean) {%sortMerge = $4;}
		
		if (%arr1 && %arr2)
		{
			%arr1Length = %arr1[]#
			%diff = 0
			%n = 0;
			for (%i = 0; %i < %arr2[]#; %i++)
			{
				if (%unique)
				{
					if ($str.grep(%arr2[%i],%arr1) == $false)
					{
						%arr1[$(%arr1Length + %i - %diff)] = %arr2[%i];
					}
					else
					{
						%diff++
					}
				}
				else
				{
					%arr1[$(%arr1Length + %i - %diff)] = %arr2[%i];
				}
			}
			if (%clearEmpty)
			{
				for (%i = 0; %i < %arr1[]#; %i++)
				{
					if (%arr1[%i] != $null)
					{
						%temp[%n] = %arr1[%i]
						%n++
					}
				}
				%arr1 = %temp
			}
			if (%sortMerge)
			{
				%arr1 = $sort(%arr1)
			}
			%success = %arr1
		}
		else
		{
			if (%G_hush->%debug) {debug -c Data type mismatch. One or more of the arguments was not type: 'array'. Check data and retry.;}
		}
		return %success
	}
	
	function fnArrayIterativeSearch(search an array iteratively for a value and return something)
	{
		/* This function will iterative search an array's values and return a result depending on the flag parameter
		
			YOU CAN PASS THIS FUNCTION AN UNSORTED ARRAY
		
		$fnArrayIterativeSearch(string:searchFor, array:arrayToSearch, string:returnFlag, string:matchModifier, bool:caseSensitivity)
		
		$0 - (string) string: the token to search for
		$1 - (array) array: the array to search
		$2 - (string) returnFlag: a modifier flag to change what we return as the return value
			the flag options are: 
			 value - returns the value we found in array that matches string
			 index - returns the index number of the value we found in array that matches string
			if no flag is passed index is the default.
		$3 - (string) matchModifier: modifier flags that can be used for $str.match function, alters how the search matching is done
			default is 'e' (exact match)
		$4 - (bool) caseSensitivity: if true the search is case sensitive
			default is $false (case insensitive)
		
		DEV-NOTE: THIS FUNCTION RETURNS boolean $false IF NO MATCH IS FOUND. The calling function __MUST__ check the type of the returned 
		value with $typeOf to see if it is a boolean since the value 0 is a valid return value from this function!
		*/
		
		%string = $0
		%array = $1
		
		if ($2) %flag = $2; else %flag = index;
		if ($3) %matchMod = $3; else %matchMod = e;
		if ($4) %caseSense = $4; else %caseSense = $false;
		
		%noMatch = $true
		%return = $false
		
		for (%i = 0; %i < %array[]#; %i++)
		{
			if ($str.match(%string,%array[%i],%matchMod,%caseSense))
			{
				switch(%flag)
				{
					case(value):
					%return = %array[%i];
					break;
					default:
					%return = %i;
					break;
				}
				%noMatch = $false;
			}
			if (!%noMatch) {break;}
		}
		
		return %return;
	}
	
	function fnArrayBinarySearch(binary search a <b>sorted array</b> and return some result)
	{
		/* This function will binary search an array's values and return a result depending on the flag parameter
		
			YOU MUST PASS THIS FUNCTION A SORTED ARRAY FOR IT TO WORK CORRECTLY
		
		$0 - (string) string: the token to search for
		$1 - (array) array: the array to search
		$2 - (string) returnFlag: a modifier flag to change what we return as the return value
			the flag options are: 
			 value - returns the value we found in array that matches string
			 index - returns the index number of the value we found in array that matches string
			if no flag is passed index is the default.
		$3 - (string) matchModifier: modifier flags that can be used for $str.match function, alters how the search matching is done
			default is 'e' (exact match)
		$4 - (bool) caseSensitivity: if true the search is case sensitive
			default is $false (case insensitive)
		
		DEV-NOTE: THIS FUNCTION RETURNS boolean $false IF NO MATCH IS FOUND. The calling function __MUST__ check the type of the returned 
		value with $typeOf to see if it is a boolean since the value 0 is a valid return value from this function!
		*/
		
		%string = $0
		%array = $1
		
		if ($2) %flag = $2; else %flag = index;
		if ($3) %matchMod = $3; else %matchMod = e;
		if ($4) %caseSense = $4; else %caseSense = $false;
		
		%noMatch = $true
		%return = $false
		
		
		// A iterative binary search function. It returns 
		// location of x in given array arr[l..r] if present, 
		// otherwise -1 
		
		if (%string && $typeOf(%array) == array)
		{
			%l = 0
			%r = $(%array[]#)
			while (%l <= %r)
			{ 
				%m = $(%l + (%r - %l) / 2); 
				if ($str.match(%string,%array[%m],%matchMod,%caseSense))
				{
					switch(%flag)
					{
						case(value):
						%return = %array[%m];
						break;
						default:
						%return = %m;
						break;
					}
				}  
				if (%array[%m] < %string) {%l = $(%m + 1);}
				else {%r = $(%m - 1);}
			}
			// if we reach here, then element was not found
			return %return;
		}
	}
	
}

class("hush::channels","widget")
{
	function constructor(initializes widgets for the Channels setting window)
	{
		# channels class for hush - builds the Channels settings window
		
		@%layout = $new(layout, $$)
		
		@$setGeometry(0,0,400,250)
		@$setWindowTitle("Hush::Settings::Channels")
		@$centerToScreen()
		@$setFocus()
		
		@%layout->$setSpacing(3)
		
		### init child widgets for Settings::Channels
		# Label to get user started
		@%lblHomeMsg = $new(label, $$)
		@%lblHomeMsg->$setText("<b>Channels</b>")
		@%lblHomeMsg->$setTooltip("Configure which channels Hush should watch for content.<br/>Enter channel names only. You can watch channels from multiple networks. Network names are not needed, Hush takes care of that.")
		@%lblHomeMsg->$setAlignment(Left)
		# Channel name linedit input
		@%leCN = $new(lineedit, $$)
		@%leCN->$setText("Enter channel to add...")
		@%leCN->$setTooltip("Type the channel name to watch.<br/>It should be the channel that has the bots announcing their packs.<br/>Just enter the channel name, Hush will deal with multiple networks itself.")
		# Channel add button
		@%btnAdd = $new(button, $$)
		@%btnAdd->$setText("Add")
		@%btnAdd->$setTooltip("Click to add the channel to the watched list.")
		# Watched Channels listbox
		@%lbC = $new(listbox, $$)
		@%lbC->$setTooltip("Your currently watched channels.")
		@%lbC->$setSelectionMode(Multi)
		# Channel remove button
		@%btnRm = $new(button, $$)
		@%btnRm->$setText("Remove")
		@%btnRm->$setTooltip("Click to remove the selected channel(s) from the channels list.")
		
		### Populate child widgets as required
		# channel list needs to be populated from %G_hushWatchedChannels to @%lbC listbox
		for (%i = 0; %i < $length(%G_hushWatchChannels); %i++)
			@%lbC->$insertItem(%G_hushWatchChannels[%i])
		
		# do layout
		@%layout->$addMultiCellWidget(@%lblHomeMsg, 0,0,0,1)
		@%layout->$addMultiCellWidget(@%leCN, 1,1,0,0)
		@%layout->$addMultiCellWidget(@%btnAdd, 1,1,1,1)
		@%layout->$addMultiCellWidget(@%lbC, 2,2,0,1)
		@%layout->$addMultiCellWidget(@%btnRm, 3,3,0,1)
		
		### private impls
		
		# channel lineedit input box, change text from default "Enter channel to add..." to "#" for channel addition
		privateimpl(@%leCN, mousePressEvent)
		{
			if (@$text() == "Enter channel to add..." || @$text() == "")
				@$setText("#")
		}
		
		privateimpl(@%leCN, keyPressEvent)
		{
			if ($0 == "Return")
				@$emit("enterPressed")
		}
		
		# connect @%leCN enterPressed event to @%btnAdd mousepressEvent
		objects.connect @%leCN enterPressed @%btnAdd mousePressEvent
		
		# channel add button, add the channel in %leCH lineedit to %lbC listbox
		privateimpl(@%btnAdd, mousePressEvent)
		{
			# check if text in %leCN exists, add to %lbC if it does
			if (@$parent->%leCN->$text() != "")
			{
				# check if input string has # at the start of it, if not, prepend it
				if ($str.left(@$parent->%leCN->$text(),1) != "#")
				{
					@$parent->%leCN->$setText($str.prepend(@$parent->%leCN->$text(), "#"))
				}
				# move channel name from lineedit to listbox
				@$parent->%lbC->$insertItem(@$parent->%leCN->$text())
				# reset lineedit value to "#"
				@$parent->%leCN->$setText("#")
			}
			else
				return $false
		}
		
		privateimpl(@%lbC, keyPressEvent)
		{
			if ($0 == "Del" || $0 == "Backspace")
				@$emit("deletePressed")
		}
		
		# connect @%lbC deletePressed event to @%btnRm mousepressEvent
		objects.connect @%lbC deletePressed @%btnRm mousePressEvent
		
		# channel remove button, remove the channel from %lbC listbox
		privateimpl(@%btnRm, mousePressEvent)
		{
			# get selected lb entries, if null go false else remove each uid that is selected
			%selectedChans = $rsort(@$parent->%lbC->$selectedItems())
			if (%selectedChans == $null)
				return $false
			else
				foreach(%uid, %selectedChans)
					@$parent->%lbC->$removeItem(%uid)
		}
		
		# close event
		privateimpl($$, closeEvent)
		{
			# closing the settings::channels windows so we need to set and save all the values
			%fn = "constructor::closeEvent"
			unset %G_hushWatchChannels
			for (%i = 0; %i < @%lbC->$count(); %i++)
				%G_hushWatchChannels[%i] = @%lbC->$textAt(%i)
		}
	}
	
}

